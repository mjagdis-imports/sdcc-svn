/* A portme.c for SDCC (or IAR or Cosmic or Raisonance) targeting the STM8/128-EVAL board

   (c) 2018 Philipp Klaus Krause

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   Free Software Foundation; either version 2, or (at your option) any
   later version. */

#include <stdio.h>

#include "stdcbench.h"

void stdcbench_error(const char *message)
{
	printf("ERROR: %s\n", message);
}

#include <stdio.h>
#include <stdint.h>

#if __STDC_VERSION__ < 201112L
#define _Noreturn
#endif

#define PA_DDR	(*(volatile uint8_t *)0x5002)
#define PA_CR1	(*(volatile uint8_t *)0x5003)

#define CLK_SWR	(*(volatile uint8_t *)0x50c4)
#define CLK_SWCR	(*(volatile uint8_t *)0x50c5)
#define CLK_DIVR	(*(volatile uint8_t *)0x50c6)
#define CLK_PCKENR1	(*(volatile uint8_t *)0x50c7)
#define CLK_PCKENR2	(*(volatile uint8_t *)0x50ca)

#define USART1_SR	(*(volatile uint8_t *)0x5230)
#define USART1_DR	(*(volatile uint8_t *)0x5231)
#define USART1_BRR1	(*(volatile uint8_t *)0x5232)
#define USART1_BRR2	(*(volatile uint8_t *)0x5233)
#define USART1_CR2	(*(volatile uint8_t *)0x5235)
#define USART1_CR3	(*(volatile uint8_t *)0x5236)

#define TIM1_CR1	(*(volatile uint8_t *)0x5250)
#define TIM1_CNTRH	(*(volatile uint8_t *)0x525e)
#define TIM1_CNTRL	(*(volatile uint8_t *)0x525f)
#define TIM1_PSCRH	(*(volatile uint8_t *)0x5260)
#define TIM1_PSCRL	(*(volatile uint8_t *)0x5261)

#define USART_CR2_TEN (1 << 3)
#define USART_CR3_STOP2 (1 << 5)
#define USART_CR3_STOP1 (1 << 4)
#define USART_SR_TXE (1 << 7)

// The STM8S208MB has an undocumented stack roll-over limit at 0x1400.
// Thus at the default stack location of 0x17ff, we have only 1 KB of stack space.
#ifdef __SDCC
void stackinit(void) __naked
{
__asm
.area GSINIT
	ldw	x, #0x13ff
	ldw	sp, x
.area CODE
__endasm;
}
#endif

void init(void)
{
	// Set the frequency to 24 MHz (flash wait state needs to be set in option bytes)
	CLK_DIVR = 0x00;
	CLK_SWR = 0xb4;
	while(!(CLK_SWCR & 0x08));
	CLK_SWCR |= 0x02;

	CLK_PCKENR2 |= 0x02; // Enable clock to timer

	// Configure timer
	// 1000 ticks per second
	TIM1_PSCRH = 0x5d;
	TIM1_PSCRL = 0xc0;
	// Enable timer
	TIM1_CR1 = 0x01;

	CLK_PCKENR1 = 0xFF; // Enable peripherals

	PA_DDR = 0x08; // Put TX line on
	PA_CR1 = 0x08;

	USART1_CR2 = USART_CR2_TEN; // Allow TX & RX
	USART1_CR3 &= ~(USART_CR3_STOP1 | USART_CR3_STOP2); // 1 stop bit
	USART1_BRR2 = 0x04; USART1_BRR1 = 0x9c; // 9600 baud
}

stdcbench_clock_t stdcbench_clock(void)
{
	unsigned char h = TIM1_CNTRH;
	unsigned char l = TIM1_CNTRL;
	return((unsigned int)(h) << 8 | l);
}

#if defined(__CSMC__) // Cosmic weirdness
char putchar(char c)
{
        while(!(USART1_SR & USART_SR_TXE));

        USART1_DR = c;
        
        return c;
}
#elif defined(__RCSTM8__) // Raisonance weirdness
int putchar(char c)
{
	while(!(USART1_SR & USART_SR_TXE));

	USART1_DR = c;

	return(c);
}
#elif defined(__SDCC) && __SDCC_REVISION < 9624 // Old SDCC weirdness
void putchar(char c)
{
  	while(!(USART1_SR & USART_SR_TXE));

	USART1_DR = c;
}
#else // Standard C
int putchar(int c)
{
	while(!(USART1_SR & USART_SR_TXE));

	USART1_DR = c;

	return(c);
}
#endif

_Noreturn void main(void)
{
	unsigned long score;

	init();
		
	printf("\n%s\n", stdcbench_name_version_string);

	score = stdcbench();

#ifdef C90BASE
	printf("stdcbench c90base score: %lu\n", c90base_score);
#endif
#ifdef C90LIB
	printf("stdcbench c90lib score: %lu\n", c90lib_score);
#endif
	printf("stdcbench final score: %lu\n", score);

	for(;;);
}

