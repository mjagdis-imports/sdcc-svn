% -------------------------------------------------------------------------
% manual.tex - f8 manual

% Copyright (c) 2024, Philipp Klaus Krause philipp@colecovision.eu)

% This program is free software; you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation; either version 2, or (at your option) any
% later version.

% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
% -------------------------------------------------------------------------*/

\documentclass{book}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage[english]{isodate}
\renewcommand{\cellalign}{tl}

\isodate

\title{f8 manual}
\author{Philipp Klaus Krause}

\begin{document}

\maketitle

\chapter{Architecture}

\section{Introduction}

Little-endian. Stack grows downward. 16-bit flat address space.

\texttt{pc} after reset: 0x4000. Other registers (including \texttt{sp}) after reset: unspecified. (P)ROM/Flash from 0x4000. RAM up to 0x3fff. I/O from 0x0000. Empty PROM/Flash is logically 0x00 (to trigger trap). All instructions execute atomically. Memory reads have no side-effects.

Safety features: trap on opcode 0x00. Trap on write to address 0x0000.

\section{Registers}

There is an 8-bit flag register \texttt{f}, which contains the half-carry flag \texttt{h}, the carry flag \texttt{c}, the negative flag \texttt{n}, the zero flag \texttt{z}, the overflow / parity flag \texttt{o}, and three reserved bits. Unless otherwise noted, instructions leave the reserved flags in an undefined state. The reserved bits should not be written by the user except via the \texttt{xch f, (}n\texttt{, sp)} instruction.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.050\linewidth]{8}
	\bitheader{0,7} \\
	\bitbox{1}{\texttt{h}} & \bitbox{1}{\texttt{c}} & \bitbox{1}{\texttt{n}} & \bitbox{1}{\texttt{z}} & \bitbox{1}{\texttt{o}} & \bitbox{3}{reserved}
\end{bytefield}

\vspace{3mm}
There are a 16-bit program counter \texttt{pc} and a 16-bit stack pointer \texttt{sp}.

\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{pc}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{sp}}
\end{bytefield}

There are three 16-bit general-purpose registers, each consisting of two 8.bit registers.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{x}} \\
	\bitbox{8}{\texttt{xl}} &
	\bitbox{8}{\texttt{xh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{y}} \\
	\bitbox{8}{\texttt{yl}} &
	\bitbox{8}{\texttt{yh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{z}} \\
	\bitbox{8}{\texttt{zl}} &
	\bitbox{8}{\texttt{zh}}
\end{bytefield}

\section{Instructions}

There is the f8 lightweight instruction subset f8l.

Instructions have up to 3 source and up to 2 destination operands. At most one source and one destination operand are in memory. All destination operands in general-purpose registers need to be one 16 bit register or part of the same 16-bit genral-purpose register.

Each instruction is encoded by 1 to 4 bytes: an optional prefix byte is followed by the opcode byte and 0 to 2 operand bytes.

There are 8 prefix bytes:

\begin{tabular}{l l l}
Prefix & semantics & group \\
\texttt{swapop} & swap operands & 0 \\
\texttt{altacc1} & alternative acumulator \texttt{xh} instead of \texttt{xl} & 1 \\
\texttt{altacc2} & alternative acumulator \texttt{yl} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc4} & alternative acumulator \texttt{yh} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc3} & alternative acumulator \texttt{zl} instead of \texttt{xl}, \texttt{x} instead of \texttt{y} & 2 \\
\texttt{altacc5} & alternative acumulator \texttt{zh} instead of \texttt{xl} & 2
\end{tabular}

\section{Addressing Modes}

\begin{tabular}{l l l}
\texttt{xl}, \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh}, \texttt{f} & 8-bit register \\
\texttt{x}, \texttt{y}, \texttt{z}, \texttt{sp} & 16-bit register \\
\texttt{\#i} & 8-bit immediate \\
\texttt{\#ii} & 16-bit immediate \\
\texttt{\#d} & 8-bit immediate sign-extended to 16 bit \\
\texttt{mm} & direct \\
\texttt{(n, sp)}, \texttt{(n, y)} & indexed with 8-bit offset \\
\texttt{(nn, z)} & indexed with 16-bit offset \\
\texttt{(x)}, \texttt{(y)}, \texttt{(z)} & indirect
\end{tabular}


\chapter{Instructions}

\begin{tabular}{l l l}
\texttt{op8\_2} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{\#i}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{op8\_2ni} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{altacc8} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh}. \\
\texttt{op16\_2} & Any of \texttt{x}, \texttt{\#ii}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{op16\_2ni} & Any of \texttt{x}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{altacc16} & Any of \texttt{x}, \texttt{z}. \\
\texttt{op8\_1} & Any of \texttt{xl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(n, y)}. \\
\texttt{op16\_1} & Any of \texttt{y}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\end{tabular}

\section{8-bit two-operand instructions}

Instructions where the location is used for \texttt{altacc8} and \texttt{op8} are not valid.

\subsection{adc: 8-bit addition with carry}

\begin{tabular}{l l l}
Assembler code               & Operation                               & f8l \\
\texttt{adc xl, op8\_2}      & \texttt{xl = xl + op8\_2 + c}           & Yes \\
\texttt{adc altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2 + c} & Yes \\
\texttt{adc op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni + xl + c}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{add: 8-bit addition}

\begin{tabular}{l l l}
Assembler code               & Operation                           & f8l \\
\texttt{add xl, op8\_2}      & \texttt{xl = xl + op8\_2}           & Yes \\
\texttt{add altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2} & Yes \\
\texttt{add op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni + xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{and: 8-bit bitwise and}

\begin{tabular}{l l l}
Assembler code               & Operation                            & f8l \\
\texttt{and xl, op8\_2}      & \texttt{xl = xl \& op8\_2}           & Yes \\
\texttt{and altacc8, op8\_2} & \texttt{altacc8 = altacc8 \& op8\_2} & Yes \\
\texttt{and op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \& xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{cp: 8-bit comparison}

Subtraction where the result is used to update the flags only.

\begin{tabular}{l l l}
Assembler code              & Operation                         & f8l\\
\texttt{cp xl, op8\_2}      & \texttt{xl + \~{}op8\_2 + 1}      & Yes \\
\texttt{cp altacc8, op8\_2} & \texttt{altacc8 + \~{}op8\_2 + 1} & Yes \\
\texttt{cp op8\_2, xl}      & \texttt{op8\_2 + \~{}xl + 1}      & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{or: 8-bit bitwise or}

\begin{tabular}{l l l}
Assembler code              & Operation                           & f8l \\
\texttt{or xl, op8\_2}      & \texttt{xl = xl | op8\_2}           & Yes \\
\texttt{or altacc8, op8\_2} & \texttt{altacc8 = altacc8 | op8\_2} & Yes \\
\texttt{or op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni | xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{sbc: 8-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code                 & Operation                                     & f8l \\
\texttt{sbc xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + c}           & Yes \\
\texttt{sbc altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + c} & Yes \\
\texttt{sbc op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + c}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{sub: 8-bit subtraction}

\begin{tabular}{l l l}
Assembler code                 & Operation                                     & f8l \\
\texttt{sub xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + 1}           & Yes \\
\texttt{sub altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + 1} & Yes \\
\texttt{sub op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + 1}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{xor: 8-bit bitwise exclusive or}

\begin{tabular}{l l l}
Assembler code               & Operation                              & f8l \\
\texttt{xor xl, op8\_2}      & \texttt{xl = xl \^{} op8\_2}           & Yes \\
\texttt{xor altacc8, op8\_2} & \texttt{altacc8 = altacc8 \^{} op8\_2} & Yes \\
\texttt{xor op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \^{} xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\section{16-bit 2-operand-instructions}

Todo: Document possible altacc prefixes.

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                              & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2 + c}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{addw: 16 bit addition}

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{orw: 16 bit bitwise or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code             & Operation                          & f8l \\
\texttt{orw xl, op16\_2}   & \texttt{y = y | op16\_2}           & No \\
\texttt{orw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni | y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\subsection{sbcw: 16 bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{sbcw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + c}       & No \\
\texttt{sbcw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{subw: 16 bit subtraction}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{subw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + 1}       & No \\
\texttt{subw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + 1} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{xorw: 16 bit bitwise exclusive or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{xorw xl, op16\_2}   & \texttt{y = y \^{} op16\_2}           & No \\
\texttt{xorw op16\_2ni, xl} & \texttt{op16\_ni2 = op16\_2ni \^{} y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\section{8-bit 1-operand-instructions}

\subsection{clr: 8-bit clear}

\begin{tabular}{l l l}
Assembler code       & Operation               & f8l \\
\texttt{clr op8\_1}  & \texttt{op8 = 0x00}     & Yes, except (n, y) \\
\texttt{clr altacc8} & \texttt{altacc8 = 0x00} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Initalizing or setting an object, or parts thereof, to 0 is common, so having a dedicated instruction is worth it vs. using \texttt{ld}.


\subsection{dec: 8-bit decrement}

\begin{tabular}{l l l}
Assembler code       & Operation                       & f8l \\
\texttt{dec op8\_1}  & \texttt{op8 = op8 + -1}         & Yes, except (n, y) \\
\texttt{dec altacc8} & \texttt{altacc8 = altacc8 + -1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{inc: 8-bit increment}

\begin{tabular}{l l l}
Assembler code       & Operation                      & f8l \\
\texttt{inc op8\_1}  & \texttt{op8 = op8 + 1}         & Yes, except (n, y) \\
\texttt{inc altacc8} & \texttt{altacc8 = altacc8 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{push: 8-bit push onto stack}

\begin{tabular}{l l l}
Assembler code        & Operation                 & f8l \\
\texttt{push op8\_1}  & \texttt{(--sp) = op8}     & Yes, except (n, y) \\
\texttt{push altacc8} & \texttt{(--sp) = altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

8-bit stack parameters can be passed easily via this instruction. Registers can be saved temporarily (e.g. for the duration of a function call, or in the middle of a complex computation). Not affecting flags makes the instruction more useful for saving registers in the middle of a long addition/subtraction/comparison/multiplication.


\subsection{sll: 8-bit shift left logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                   & f8l \\
\texttt{sll op8\_1}  & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{op8 = op8 << 1}}         & Yes, except (n, y) \\
\texttt{sll altacc8} & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{altacc8 = altacc8 << 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{srl: 8-bit shift right logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                            & f8l \\
\texttt{srl op8\_1}  & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{op8 = op8 >> 1}}         & Yes, except (n, y) \\
\texttt{srl altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = altacc8 >> 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{rlc: 8-bit rotate left through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rlc op8\_1}  & \makecell{\texttt{tc = (op8  \& 0x80) >> 7}\\\texttt{op8 = (op8 << 1) | c}\\\texttt{c = tc}}            & Yes, except (n, y) \\
\texttt{rlc altacc8} & \makecell{\texttt{tc = (altacc8 \& 0x80) >> 7}\\\texttt{altacc8 = (altacc8 << 1) | c}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{rrc: 8-bit rotate right through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rrc op8\_1}  & \makecell{\texttt{tc = op8  \& 0x01}\\\texttt{op8 = (op8 >> 1) | (c << 7)}\\\texttt{c = tc}}            & Yes, except (n, y) \\
\texttt{rrc altacc8} & \makecell{\texttt{tc = altacc8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | (c << 7)}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{tst: 8-bit test}

Set n and z flags according to value of operand, o flag by parity, reset c.

\begin{tabular}{l l l}
Assembler code       & Operation        & f8l \\
\texttt{tst op8\_1}  & \texttt{op8}     & Yes, except (n, y) \\
\texttt{tst altacc8} & \texttt{altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

Testing a variable for zero or being nonnegative is common. We also want a way to check parity and reset the carry flag. Making that a side-effect in this instructions saves opcodes for other uses.


\section{16-bit 1-operand-instructions}

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{adcw op16\_1}  & \texttt{op16 = op16 + c}         & No \\
\texttt{adcw altacc16} & \texttt{altacc16 = altacc16 + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

In additions, often one operand is a small integer. This instructions allows an efficient implementation of the handling of the upper bits.


\subsection{clrw: 16-bit clear}

\begin{tabular}{l l l}
Assembler code         & Operation                  & f8l \\
\texttt{clrw op16\_1}  & \texttt{op16 = 0x0000}     & Yes \\
\texttt{clrw altacc15} & \texttt{altacc16 = 0x0000} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Initalizing or setting an object, or parts thereof, to 0 is common, so having a dedicated instruction is worth it vs. using \texttt{ldw}.


\subsection{incw: 16-bit increment}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{incw op16\_1}  & \texttt{op16 = op16 + 1}         & Yes \\
\texttt{incw altacc16} & \texttt{altacc16 = altacc16 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

Incrementing a variable is common, so having a dedicated instruction is worth it vs. using \texttt{addw}. Affecting the carry flag makes this instruction less useful for incrementing pointers in the middle of wider arithmetic operations, but makes it more useful for incrementing wider variables.


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code          & Operation                         & f8l \\
\texttt{pushw op16\_1}  & \texttt{sp -= 2; (sp) = op16}     & Yes \\
\texttt{pushw altacc16} & \texttt{sp -= 2; (sp) = altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

16-bit stack parameters can be passed easily via this instruction. Registers can be saved temporarily for a function call, or in the middle of wider arithmetic operations; for the latter use, it is important that this instruction doesnot affect any flags.


\subsection{sbcw: 16-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                 & f8l \\
\texttt{sbcw op16\_1}  & \texttt{op16 = op16 + 0xffff + c}         & No \\
\texttt{sbcw altacc16} & \texttt{altacc16 = altacc16 + 0xffff + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

In subtractions, often one operand is a small integer. This instructions allows an efficient implementation of the handling of the upper bits.


\subsection{tstw: 16-bit test}

Set n and z flags according to value of operand, o flag by parity, set c.

\begin{tabular}{l l l}
Assembler code         & Operation         & f8l \\
\texttt{tstw op16\_1}  & \texttt{op16}     & Yes \\
\texttt{tstw altacc16} & \texttt{altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

Testing a variable for zero or being nonnegative is common. We also want a way to check parity and set the carry flag. Making that a side-effect in this instructions saves opcodes for other uses.


\section{8-bit loads}

\subsection{ld: 8-bit load from memory}

\begin{tabular}{l l l}
Assembler code                  & Operation                     & f8l \\
\texttt{ld xl, \#i}             & \texttt{xl = \#i}             & Yes \\
\texttt{ld altacc8, \#i}        & \texttt{altacc8 = \#i}        & Yes \\
\texttt{ld xl, mm}              & \texttt{xl = mm}              & Yes \\
\texttt{ld altacc8, mm}         & \texttt{altacc8 = mm}         & Yes \\
\texttt{ld xl, (n, sp)}         & \texttt{xl = (n, sp)}         & Yes \\
\texttt{ld altacc8, (n, sp)}    & \texttt{altacc8 = (n, sp)}    & Yes \\
\texttt{ld xl, (nn, z)}         & \texttt{xl = (nn, z)}         & Yes \\
\texttt{ld altacc8, (nn, z)}    & \texttt{altacc8 = (nn, z)}    & Yes \\
\texttt{ld xl, (y)}             & \texttt{xl = xh}              & Yes \\
\texttt{ld altacc8, (altacc16)} & \texttt{altacc8 = (altacc16)} & Yes \\
\texttt{ld xl, (n, y)}          & \texttt{xl = (n, y)}          & No \\
\texttt{ld altacc8, (n, y)}     & \texttt{altacc8 = (n, y)}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

To be able to handle 8-bit data efficiently, we need a variety of 8-bit load instructions. Often, data is being tested for being (non)zero or (non)negative after being loaded from memory, so having \texttt{ld} update the \texttt{n} and \texttt{z} flags can save a \texttt{tst} instruction.


\subsection{ld: 8-bit load from register}

\begin{tabular}{l l l}
Assembler code                  & Operation                     & f8l \\
\texttt{ld xl, xh}              & \texttt{xl = xh}              & Yes \\
\texttt{ld xh, xl}              & \texttt{xh = xl}              & Yes \\
\texttt{ld altacc8, xh}         & \texttt{altacc8 = xh}         & Yes \\
\texttt{ld xl, yl}              & \texttt{xl = yl}              & Yes \\
\texttt{ld yl, xl}              & \texttt{yl = xl}              & Yes \\
\texttt{ld altacc8, yl}         & \texttt{altacc8 = yl}         & Yes \\
\texttt{ld xl, yh}              & \texttt{xl = yh}              & Yes \\
\texttt{ld yh, xl}              & \texttt{yh = xl}              & Yes \\
\texttt{ld altacc8, yh}         & \texttt{altacc8 = yh}         & Yes \\
\texttt{ld xl, zl}              & \texttt{xl = zl}              & Yes \\
\texttt{ld zl, xl}              & \texttt{zl = xl}              & Yes \\
\texttt{ld altacc8, zl}         & \texttt{altacc8 = zl}         & Yes \\
\texttt{ld xl, zh}              & \texttt{xl = zh}              & Yes \\
\texttt{ld zh, xl}              & \texttt{zh = xl}              & Yes \\
\texttt{ld altacc8, zh}         & \texttt{altacc8 = zh}         & Yes \\
\texttt{ld mm, xl}              & \texttt{mm = xl}              & Yes \\
\texttt{ld mm, altacc8}         & \texttt{mm = altacc8}         & Yes \\
\texttt{ld (n, sp), xl}         & \texttt{(n, sp) = xl}         & Yes \\
\texttt{ld (n, sp), altacc8}    & \texttt{(n, sp) = altacc8}    & Yes \\
\texttt{ld (nn, z), xl}         & \texttt{(nn, z) = altacc8}    & Yes \\
\texttt{ld (nn, z), altacc8}    & \texttt{(nn, z) = altacc8}    & Yes \\
\texttt{ld (y), xl}             & \texttt{(y) = xl}             & Yes \\
\texttt{ld (altacc16), altacc8} & \texttt{(altacc16) = altacc8} & Yes \\
\texttt{ld (n, y), xl}          & \texttt{(n, y) = xl}          & No \\
\texttt{ld (n, y), altacc8}     & \texttt{(n, y) = altacc8}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

To be able to handle 8-bit data efficiently, we need a variety of 8-bit load instructions.

\subsection{ldi: 8-bit load with increment}

Flags according to old (y).

\begin{tabular}{l l l}
Assembler code           & Operation                      & f8l \\
\texttt{ldi (n, y), (z)} & \texttt{(n, y) = (z); z += 1;} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

Copying larger blocks of data is a very common operation, both explicitly via \texttt{memcpy}, and when assigning larger variables. While \texttt{ldwi} has higher throughput, this instruction can be used for the first or last byte when copying an odd number of bytes. Due to its effect on the \texttt{z} flag, it is also useful, when the value of the individual copied byte matters, in particular for implementing \texttt{strlen} and \texttt{strnlen}.


\section{16-bit loads}

\subsection{ldw: 16-bit load from memory}

\begin{tabular}{l l l}
Assembler code                    & Operation                      & f8l \\
\texttt{ldw y, \#ii}              & \texttt{y = \#ii}              & Yes \\
\texttt{ldw altacc16, \#ii}       & \texttt{altacc16 = \#ii}       & Yes \\
\texttt{ldw y, mm}                & \texttt{y = mm}                & Yes \\
\texttt{ldw altacc16, mm}         & \texttt{altacc16 = mm}         & Yes \\
\texttt{ldw y, (n, sp)}           & \texttt{y = (n, sp)}           & Yes \\
\texttt{ldw altacc16, (n, sp)}    & \texttt{altacc16 = (n, sp)}    & Yes \\
\texttt{ldw y, (nn, z)}           & \texttt{y = (nn, z)}           & Yes \\
\texttt{ldw altacc16, (nn, z)}    & \texttt{altacc16 = (nn, z)}    & Yes \\
\texttt{ldw y, (n, y)}            & \texttt{y = (n, y)}            & No \\
\texttt{ldw altacc16, (n, y)}     & \texttt{altacc16 = (n, y)}     & No \\
\texttt{ldw y, (y)}               & \texttt{y = (y)}               & Yes \\
\texttt{ldw altacc16, (altacc16)} & \texttt{altacc16 = (altacc16)} & Yes \\
\texttt{ldw y, \#d}               & \texttt{y = \#d}               & Yes \\
\texttt{ldw altacc16, \#d}        & \texttt{altacc16 = \#d}        & Yes \\
\texttt{ldw x, (y)}               & \texttt{x = (y)}               & Yes \\
\texttt{ldw y, (z)}               & \texttt{y = (z)}               & Yes \\
\texttt{ldw z, (x)}               & \texttt{z = (x)}               & Yes \\
\texttt{ldw z, (y)}               & \texttt{z = (y)}               & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

To be able to handle 16-bit data efficiently, we need a variety of 16-bit load instructions. Often, data is being tested for being (non)zero or (non)negative after being loaded from memory, so having \texttt{ldw} update the \texttt{n} and \texttt{z} flags can save a \texttt{tstw} instruction.


\subsection{ldw 16-bit load from register}

\begin{tabular}{l l l}
Assembler code                   & Operation                   & f8l \\
\texttt{ldw y, x}                & \texttt{y = x}              & Yes \\
\texttt{ldw y, z}                & \texttt{x = z}              & Yes \\
\texttt{ldw z, x}                & \texttt{x = z}              & Yes \\
\texttt{ldw x, z}                & \texttt{x = z}              & Yes \\
\texttt{ldw mm, y}               & \texttt{mm = y}             & Yes \\
\texttt{ldw mm, altacc16}        & \texttt{mm = altacc16}      & Yes \\
\texttt{ldw (n, sp), y}          & \texttt{(n, sp) = y}        & Yes \\
\texttt{ldw (n, sp), altacc16}   & \texttt{(n, sp) = altacc16} & Yes \\
\texttt{ldw (nn, z), y}          & \texttt{(nn, z) = y}        & Yes \\
\texttt{ldw (nn, z), altacc16}   & \texttt{(nn, z) = altacc16} & Yes \\
\texttt{ldw x, y}                & \texttt{x = y}              & Yes \\
\texttt{ldw z, y}                & \texttt{z = y}              & Yes \\
\texttt{ldw y, z}                & \texttt{y = z}              & Yes \\
\texttt{ldw z, x}                & \texttt{z = x}              & Yes \\
\texttt{ldw (y), x}              & \texttt{(y) = x}            & Yes \\
\texttt{ldw (z), y}              & \texttt{(z) = y}            & Yes \\
\texttt{ldw (x), z}              & \texttt{(x) = z}            & Yes \\
\texttt{ldw (y), z}              & \texttt{(y) = z}            & Yes \\
\texttt{ldw (n, y), x}           & \texttt{(n, y) = x}         & No \\
\texttt{ldw y, sp}               & \texttt{y = sp}             & Yes \\
\texttt{ldw sp, y}               & \texttt{sp = y}             & Yes \\
\texttt{ldw altacc16, sp}        & \texttt{altacc16 = sp}      & Yes \\
\texttt{ldw ((d, sp)), y}        & \texttt{(d, sp) = y}        & No \\
\texttt{ldw ((d, sp)), altacc16} & \texttt{(d, sp) = altacc16} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

To be able to handle 16-bit data efficiently, we need a variety of 16-bit load instructions.


\subsection{ldwi: 16-bit load with increment}

Flags according to old (y).

\begin{tabular}{l l l}
Assembler code         & Operation                         & f8l \\
\texttt{ldwi (n, y), (z)} & \texttt{(n, y) = (z); z += 2;} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

Copying larger blocks of data is a very common operation, both explicitly via \texttt{memcpy}, and when assigning larger variables. This instruction substantially increases throughput vs. using individual loads and stores. The effect on the \texttt{z} flag makes it suitable for copying zero-terminated UTF-16 strings.


\subsection{sex: sign-extend}

\begin{tabular}{l l l}
Assembler code                 & Operation                            & f8l \\
\texttt{sex y, xl}             & \texttt{y = (int8\_t)xl}             & No \\
\texttt{sex altacc16, altacc8} & \texttt{altacc16 = (int8\_t)altacc8} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

When aiming for memory-efficiency, it is important to be able to chose the smallest type that can hold the data without incurring a code size or performance penalty. This instruction allows efficient up-casts of signed numbers.


\subsection{zex: zero-extend}

\begin{tabular}{l l l}
Assembler code                 & Operation                   & f8l \\
\texttt{zex y, xl}             & \texttt{y = xl}             & No \\
\texttt{zex altacc16, altacc8} & \texttt{altacc16 = altacc8} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

When aiming for memory-efficiency, it is important to be able to chose the smallest type that can hold the data without incurring a code size or performance penalty. This instruction help implement efficient up-casts of unsigned numbers. Its benefits are not as big as those of \texttt{sex} per individual upcast, but onthe other hand, unsigned numbers are used more commonly, thus unsigned upcasts are more common.


\section{Other 8-bit instructions}

\subsection{bool: 8-bit cast to bool}

Todo: Remove from f8l subset?

\begin{tabular}{l l l}
Assembler code        & Operation                        & f8l \\
\texttt{bool xl}      & \texttt{xl = (bool)xl}           & Yes \\
\texttt{bool altacc8} & \texttt{altacc8 = (bool)altacc8} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

This instruction allows the efficient implentation of explicit casts of 8-bit numbers to bool and, together with the \texttt{xor} instruction, of the negation operator for 8-bit numbers.


\subsection{cax: 8-bit compare and exchange}

z is set according to the old value of (y) - zl.

\begin{tabular}{l l l}
Assembler code            & Operation                                        & f8l \\
\texttt{cax (y), zl, xl}  & \texttt{if ((y) == zl) (y) = xl; else zl = (y);} & Yes \\
\texttt{cax (y), zl, xh}  & \texttt{if ((y) == zl) (y) = xh; else zl = (y);} & Yes \\
\texttt{cax (y), zl, zh}  & \texttt{if ((y) == zl) (y) = zh; else zl = (y);} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

This instruction is essential for the implementation of 8-bit lock-free atomics.


\subsection{da: decimal adjust}

Decimal adjust for addition / subtraction - binary coded decimal semantics.

todo: describe details!

\begin{tabular}{l l l}
Assembler code      & Operation & f8l \\
\texttt{da xl}      &           & Yes \\
\texttt{da altacc8} &           & Yes \\
\end{tabular}

\subsubsection*{Rationale}

While the binary-coded-decimal (BCD) representation of numbers if mostly obsolete today, this instruction still has a use: it allows efficient conversion from binary to BCD, and thus to ASCII. This can substantially speed up the printing of numbers, considering that the f8 does not have division or modulo hardware.


\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{mad: multiply and add}

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{mad x, mm, yl}      & \texttt{x = mm * yl + xh + c}      & No \\
\texttt{mad x, (n, sp), yl} & \texttt{x = (n, sp) * yl + xh + c} & No \\
\texttt{mad x, (nn, z), yl} & \texttt{x = (nn, z) * yl + xh + c} & No \\
\texttt{mad x, (z), yl}     & \texttt{x = (z) * yl + xh + c}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

Multiplication hardware is expensive. We need it for the \texttt{mul} instruction. However, on multiplications of larger numbers, if we only had \texttt{mul}, we'd spend a lot of cycles moving and adding, and the multiplication hardware would be idle for many cycles. This instruction speeds up multiplications of large numbers substantially, so that every other instruction actually uses the multiplication hardware.


\subsection{msk: mask}

z flag set according to old value of  (y) \& \#i.

\begin{tabular}{l l l}
Assembler code                        & Operation                                                    & f8l \\
\texttt{msk (y), xl, \#i}             & \texttt{(y) = xl \& \#i | (y) \& \~{}\#i}                    & Yes \\
\texttt{msk (altacc16), altacc8, \#i} & \texttt{(altacc16) = altacc8 \& \#i | (altacc16) \& \~{}\#i} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

Bit-fields are an important tool to reduce data memory usage. This instruction allows for substantially better code for writing bit-fields, and for writing parts of i/o registers. Due to its effect on the z flag, it also can be used as a single bit exchange instruction, which can be useful on memory-mapped i/o.


\subsection{pop: 8-bit pop from stack}

\begin{tabular}{l l l}
Assembler code       & Operation                 & f8l \\
\texttt{pop xl}      & \texttt{xl = (sp++)}      & Yes \\
\texttt{pop altacc8} & \texttt{altacc8 = (sp++)} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Registers that were saved temporarily via a \texttt{push} can be restored by this instruction. Not affecting flags makes the instruction more useful for restoring registers after a comparison before a conditional jump, or in the middle of a long addition/subtraction/multiplication.


\subsection{push: 8-bit push onto stack}

Ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code    & Operation             & f8l \\
\texttt{push \#i} & \texttt{(--sp) = \#i} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

8-bit stack parameters can be passed easily via this instruction. Not affecting any flags makes this instruction, together with \texttt{xch f, (n,sp)}, suitable for saving the flags at the beginning of an interrupt handler.

\subsection{rot: 8-bit rotate}

\begin{tabular}{l l l}
Assembler code            & Operation                                                    & f8l \\
\texttt{rot xl, \#i}      & \texttt{xl = (xl << \#i) | (xl >> (8 - \#i))}                & No \\
\texttt{rot altacc8, \#i} & \texttt{altacc8 = (altacc8 << \#i) | (altacc8 >> (8 - \#i))} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}

\subsubsection*{Rationale}

8-bit rotations happen in code. Together with \texttt{and}, this instruction can be used to efficiently do shifts by more than 2. Another important use is shuffling bits around for bit-field reads and writes (and bit-fields are an important tool to reduce data memory usage).


\subsection{sra: 8-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                               & f8l \\
\texttt{sra xl}      & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{xl = (xl >> 1) | xl \& 0x80}}               & Yes \\
\texttt{sra altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | altacc \& 0x80}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

This instruction is used for right-shift of signed integers, which is also relevant to implementing signed division by powers of two.

\subsection{thrd}

Get current hardware thread number.

\begin{tabular}{l l l}
Assembler code        & Operation                                         & f8l \\
\texttt{thrd xl}      & \texttt{xl =} current hardware thread number      & Yes \\
\texttt{thrd altacc8} & \texttt{altacc8 =} current hardware thread number & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

Getting the hardware thread number efficiently is useful for implementing thread-local storage. While \texttt{thrd} will not be a common instruction is typical programs, the alternative is doing a search for the current calue of \texttt{sp} in a list of stack pointer ranges, which would be quite inefficient.


\subsection{xch: 8-bit exchange}

\begin{tabular}{l l l}
Assembler code                   & Operation                                                  & f8l \\
\texttt{xch yl, yh}              & \texttt{t = yl; yl = yh; yh = t}                           & Yes \\
\texttt{xch xl, xh}              & \texttt{t = xl; xl = xh; xh = t}                           & Yes \\
\texttt{xch zl, zh}              & \texttt{t = zl; zl = zh; zh = t}                           & Yes \\
\texttt{xch xl, (n, sp)}         & \texttt{t = (n, sp); (n, sp) = xl; xl = t}                 & No \\
\texttt{xch altacc8, (n, sp)}    & \texttt{t = (n, sp); (n, sp) = altacc8; altacc8 = t}       & No \\
\texttt{xch xl, (y)}             & \texttt{t = (y); (y) = xl; xl = t}                         & Yes \\
\texttt{xch altacc8, (altacc16)} & \texttt{t = (altacc16); (altacc16) = altacc8; altacc8 = t} & Yes \\
\texttt{xch f, (n, sp)}          & \texttt{t = (n, sp); (n, sp) = f; f = t}                   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

All, including reserved ones (\texttt{xch f, (n, sp)}) or none (all others).

\subsubsection*{Rationale}

The instruction with register and stack parameters is useful for shuffling data in registers and on the stack around, allowing for substantially more efficient register and stack allocation. The \texttt{xch xl, (y)} instruction and its variant \texttt{xch altacc8, (altacc16)} are useful for implementing 8-bit atomics. \texttt{xch f, (n, sp)} together with \texttt{push \#i} and \texttt{addw sp, \#d} is suitable for saving and restoring the flags for interrupt handlers.


\section{Other 16-bit instructions}

\subsection{addw: 16-bit addition}

\texttt{addw sp, \#d} ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{addw sp, \#d}       & \texttt{sp = sp + \#d}             & Yes \\
\texttt{addw y, \#d}        & \texttt{y = y + \#d}               & Yes \\
\texttt{addw altacc16, \#d} & \texttt{altacc16 = altacc16 + \#d} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none (\texttt{addw sp, \#d}) or \texttt{cnzo} (all others).

\subsubsection*{Rationale}

THis instruction allows to effcieintly adjust the stack pointer, which is useful for the setup of the stack at the beginning of functions,and stack cleanup at the end of a function or after a function call.


\subsection{boolw: 16-bit cast to bool}

\begin{tabular}{l l l}
Assembler code          & Operation                          & f8l \\
\texttt{boolw y}        & \texttt{y = (bool)y}               & No \\
\texttt{boolw altacc16} & \texttt{altacc16 = (bool)altacc16} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

This instruction allows the efficient implentation of explicit casts of 16-bit numbers to bool and, together with the \texttt{xor} instruction, of the negation operator for 16-bit numbers.


\subsection{caxw: 16-bit compare and exchange}

z is set according to the old value of (y) - z.

\begin{tabular}{l l l}
Assembler code           & Operation                                     & f8l \\
\texttt{caxw (y), z, x}  & \texttt{if ((y) == z) (y) = x; else z = (y);} & Yes \\

\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsubsection*{Rationale}

This instruction is essential for the implementation of 16-bit lock-free atomics.


\subsection{cpw: 16-bit comparison}

Subtraction where the result is used to update the flags only.

\begin{tabular}{l l l}
Assembler code              & Operation                        & f8l\\
\texttt{cpw y, \#ii}        & \texttt{y + \~{}\#ii + 1}        & No \\
\texttt{cpw \#ii, y}        & \texttt{\#ii + \~{}y + 1}        & No \\
\texttt{cpw altacc16, \#ii} & \texttt{altacc16 + \~{}\#ii + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

This instruction allows the efficient implementation of sparse switch statements, and of some if-else chains with a 16-bit or wider condition.


\subsection{decw: 16-bit decrement}

\begin{tabular}{l l l}
Assembler code        & Operation                       & f8l \\
\texttt{decw (n, sp)} & \texttt{(n, sp) = (n, sp) + -1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

Decrement is a common special case of subtraction, though not as common as increment as a secial case of addition.


\subsection{incnw: 16-bit increment without carry update}

Ignores all flags, changes no flags (except possibly the reserved ones).

\begin{tabular}{l l l}
Assembler code          & Operation                        & f8l \\
\texttt{incnw y}        & \texttt{y = y + 1}               & No \\
\texttt{incnw altacc16} & \texttt{altacc16 = altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Incrementing pointers is common. When needing to do so in the middle of wider or arbitrary-width arithmetic operations, the carry flag needs to be preserved across the increment.


\subsection{negw: 16-bit negation}

\begin{tabular}{l l l}
Assembler code         & Operation                            & f8l \\
\texttt{negw y}        & \texttt{y = \~{}y + 1}               & No \\
\texttt{negw altacc16} & \texttt{altacc16 = \~{}altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}

\subsubsection*{Rationale}

Negation is a common special case of subtraction.


\subsection{mul: multiplication}

Clears carry.

\begin{tabular}{l l l}
Assembler code & Operation            & f8l \\
\texttt{mul y} & \texttt{y = yl * yh} & No \\
\texttt{mul x} & \texttt{x = xl * xh} & No \\
\texttt{mul z} & \texttt{z = zl * zh} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

Multiplications are common, both explicitly and in array indexing. For efficient use of data memory, structs should not be padded, thus accessing arrays of structs often requires multiplications with factors that are not apoer of two. This instruction allows to do these multiplications efficiently. The effect of the carry flag ismotivated by the use of this instruction together with \texttt{mad} for wider multiplications.


\subsection{popw: 16-bit pop from stack}

\begin{tabular}{l l l}
Assembler code         & Operation                         & f8l \\
\texttt{popw y}        & \texttt{y = (sp); sp += 2}        & Yes \\
\texttt{popw altacc16} & \texttt{altacc16 = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

This instruction is useful torestore16-bit registers that were saved temporarily via \texttt{pushw}. It is also a code-size efficient way of adjusting hte stack pointer by 2 (but does a memory read).


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code      & Operation                     & f8l \\
\texttt{pushw \#ii} & \texttt{sp -= 2; (sp) = \#ii} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

16-bit stack parameters can be passed easily via this instruction. This is common enough to make it worth having this instruction. Compared to using \texttt{ldw} followed by a \texttt{pushw} with a register operand, we save one byte of cde size, some execution time, and donot need a free 16-bit register (which might not be easily available at calls to functions that also have register parameters).


\subsection{rlcw: 16-bit rotate left through carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                                                                                             & f8l \\
\texttt{rlcw y}        & \makecell{\texttt{tc = (y \& 0x8000) >> 15}\\\texttt{y = (y >> 1) | (c << 15)}\\\texttt{c = tc}}                      & No \\
\texttt{rlcw (n, sp)}  & \makecell{\texttt{tc = ((n, sp) \& 0x8000) >> 15}\\\texttt{(n, sp) = ((n, sp) >> 1) | (c << 15)}\\\texttt{c = tc}}    & No \\
\texttt{rlcw altacc16} & \makecell{\texttt{tc = (altacc16 \& 0x8000) >> 15}\\\texttt{altacc16 = (altacc16 >> 1) | (c << 15)}\\\texttt{c = tc}} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

This instruction is useful to implement wider shifts.


\subsection{rrcw: 16-bit rotate right through carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                                                                              & f8l \\
\texttt{rrcw y}        & \makecell{\texttt{tc = y \& 0x0001}\\\texttt{y = (y >> 1) | c}\\\texttt{c = tc}}                      & No \\
\texttt{rrcw (n, sp)}  & \makecell{\texttt{tc = (n, sp) \& 0x0001}\\\texttt{(n, sp) = ((n, sp) << 1) | c}\\\texttt{c = tc}}    & No \\
\texttt{rrcw altacc16} & \makecell{\texttt{tc = altacc16 \& 0x0001}\\\texttt{altacc16 = (altacc16 << 1) | c}\\\texttt{c = tc}} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

This instruction is useful to implement wider shifts.


\subsection{sllw: 16-bit shift left logical}

\begin{tabular}{l l l}
Assembler code                  & Operation                                     & f8l \\
\texttt{sllw y}                 & \texttt{c = y \& (0x8000 >> 15); y = y << 1}  & No \\
\texttt{sllw altacc16}          & \texttt{altacc16 = altacc16 << 1}             & No \\
\texttt{sllw y, xl}             & \texttt{c = y \& (0x8000 >> 15); y = y << xl} & No \\
\texttt{sllw altacc16, altacc8} & \texttt{altacc16 = altacc16 << altacc8}       & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz} (\texttt{sllw y} and \texttt{sllw altacc16}) or \texttt{nz} (others).

\subsubsection*{Rationale}

This instruction is useful to implement shifts of 16 or more bits.


\subsection{sraw: 16-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code         & Operation                                                               & f8l \\
\texttt{sraw y}        & \texttt{c = y \& 0x0001; y = y >> 1 | y \& 0x8000}                      & No \\
\texttt{sraw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1 | altacc16 \& 0x8000} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

This instruction is useful to implement shifts of 16 or more bits.


\subsection{srlw: 16-bit shift right logical}

\begin{tabular}{l l l}
Assembler code         & Operation                                          & f8l \\
\texttt{srlw y}        & \texttt{c = y \& 0x0001; y = y >> 1}               & No \\
\texttt{srlw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsubsection*{Rationale}

This instruction is useful to implement shifts of 16 or more bits.


\subsection{xchw: 16-bit exchange}

\begin{tabular}{l l l}
Assembler code                  & Operation                                              & f8l \\
\texttt{xchw x, (y)}            & \texttt{t = x; x = (y); (y) = t}                       & Yes \\
\texttt{xchw y, (z)}            & \texttt{t = y; y = (z); (z) = t}                       & Yes \\
\texttt{xchw z, (x)}            & \texttt{t = z; z = (x); (x) = t}                       & Yes \\
\texttt{xchw z, (y)}            & \texttt{t = z; z = (y); (y) = t}                       & Yes \\
\texttt{xchw y, (n, sp)}        & \texttt{t = y; y = (n, sp); (n, sp) = t}               & No \\
\texttt{xchw altacc16, (n, sp)} & \texttt{t = altacc16; altacc16 = (n, sp); (n, sp) = t} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

This instruction is useful to shuffle data around, and to implement 16-bit atomic exchange.


\subsubsection*{Affected Flags}

\texttt{z}


\section{Jumps}

\subsection{call}

\begin{tabular}{l l l}
Assembler code         & Operation                                  & f8l \\
\texttt{call \#ii}     & \texttt{sp -= 2; (sp) = pc; pc = \#ii}     & Yes \\
\texttt{call y}        & \texttt{sp -= 2; (sp) = pc; pc = y}        & Yes \\
\texttt{call altacc16} & \texttt{sp -= 2; (sp) = pc; pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Calling and returning from functions using a return address on the stack is common. This instruction helps implement it efficiently.


\subsection{dnjnz: decrement without carry update amd jump if not zero}

\begin{tabular}{l l l}
Assembler code         & Operation                   & f8l \\
\texttt{dnjnz yh, \#d} & \texttt{if(--yh) pc += \#d} & No \\
\texttt{dnjnz xh, \#d} & \texttt{if(--xh) pc += \#d} & No \\
\texttt{dnjnz zh, \#d} & \texttt{if(--zh) pc += \#d} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

This instruction can be used to implement while loops instead of using \texttt{dec} followed by \texttt{jr nz}. Not affecting flags make it suitable for implementing arbitrary-length arithmetic (\texttt{dec} would not preserve the carry flag, thus complicating its use). The choice of operands is motivated by the use-case of arbitrary-length multiplications via \texttt{mad}.


\subsection{jp: jump}

\texttt{jp \#ii} ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code       & Operation              & f8l \\
\texttt{jp \#ii}     & \texttt{pc = \#ii}     & Yes \\
\texttt{jp y}        & \texttt{pc = y}        & Yes \\
\texttt{jp altacc16} & \texttt{pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

A jump instruction that can reach any target is very useful to implement control-flow. Not affecting flags, not even reserved ones, makes this instruction suitable for use at the interrupt vector.


\subsection{jr: jump}

\texttt{jr \#d} ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code  & Operation          & f8l \\
\texttt{jr \#d} & \texttt{pc += \#d} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Having a jumpinstruction instruction is very useful to implement control-flow. Jumps are common, and most of them have a nearby target, making it worth having a relative jump instruction.


\subsection{jrc: jump on carry}

\begin{tabular}{l l l}
Assembler code  & Operation                  & f8l \\
\texttt{jr \#d} & \texttt{if (c) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the carry flag are useful for implementing common unsigned comparisons, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrgt: jump on greater}

\begin{tabular}{l l l}
Assembler code    & Operation                        & f8l \\
\texttt{jrgt \#d} & \texttt{if (c \&\& !z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrle}.


\subsection{jrle: jump on less or equal}

\begin{tabular}{l l l}
Assembler code    & Operation                        & f8l \\
\texttt{jrle \#d} & \texttt{if (!c || z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the carry flag together with the z flag are useful for implementing common unsigned comparisons, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrn: jump on negative}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jrn \#d} & \texttt{if (n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the n flag are useful for implementing common unsigned comparisons with 0, some bit tests, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrnc: jump on no carry}

\begin{tabular}{l l l}
Assembler code    & Operation                    & f8l \\
\texttt{jrnc \#d} & \texttt{if (!c) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrc}.


\subsection{jrnn: jump on nonnegative}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrnn \#d} & \texttt{if (!n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrn}.


\subsection{jrno: jump on no overflow}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrno \#d} & \texttt{if (!o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jro}.


\subsection{jrnz: jump on nonzero}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrnz \#d} & \texttt{if (!n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrz}.


\subsection{jro: jump on overflow}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jro \#d} & \texttt{if (o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the n flag are useful for implementing signed comparisons wide than the operands of the available compare and subtraction instructions, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrsge: jump on signed greater or equal}

\begin{tabular}{l l l}
Assembler code     & Operation                            & f8l \\
\texttt{jrsge \#d} & \texttt{if (!(n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrslt}.


\subsection{jrsgt: jump on signed greater}

\begin{tabular}{l l l}
Assembler code     & Operation                                    & f8l \\
\texttt{jrsgt \#d} & \texttt{if (!z \&\& !(n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

See \texttt{jrsle}.


\subsection{jrsle: jump on signed less or equal}

\begin{tabular}{l l l}
Assembler code   & Operation                                  & f8l \\
\texttt{jrsle \#d} & \texttt{if (z || (n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\subsubsection*{Rationale}

Conditional jumps depending on the z, n and o flags are useful for implementing signed comparisons, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrslt: jump on signed less}

\begin{tabular}{l l l}
Assembler code     & Operation                         & f8l \\
\texttt{jrslt \#d} & \texttt{if (n \^{} o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the n and o flags are useful for implementing signed comparisons, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{jrz: jump on zero}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jrz \#d} & \texttt{if (z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Conditional jumps depending on the zero flag are useful for implementing common tests for 0, and control-flow depending thereon. Since most jump targest are nearby, it makes sense to only have the relative conditional jump, as furhter jumps can still be implemented by inverting the condition and additon a unconditional jump.


\subsection{ret: return}

\begin{tabular}{l l l}
Assembler code & Operation                   & f8l \\
\texttt{ret}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

Calling and returning from functions using a return address on the stack is common. This instruction helps implement it efficiently.


\subsection{reti: return from interrupt}

Ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code  & Operation                   & f8l \\
\texttt{reti}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsubsection*{Rationale}

When returning from an interrupt handler, interrupts should be reenabled at the same time. This instruction is necessary to return and enable atomically. To ensure that all flags get restored to their state from before the interrupt handler, it may not affect any flags, not even reserved ones.


\subsection{trap}

Opcode 0x00. Trap reset.

\begin{tabular}{l l l}
Assembler code  & Operation  & f8l \\
\texttt{trap}   & Trap reset & Yes \\
\end{tabular}

\subsubsection*{Rationale}

Some bugs, including many security-relevant ones can lead to the execution of codd from memory used for data. Many exploits actually rely on data commonly being zero, and \texttt{nop} having opcode 0. By making opcode 0 a \texttt{trap} instruction, we can mitigate the impact of such bugs, and make them easier to debug.


\section{Non-instructions}

A 16-bit bitwise and \texttt{andw} would not be as useful as \texttt{orw} and \texttt{xorw}: kown 0x00 or 0xff bytes are more common for bitwise and, so the compiler will often use \texttt{ld}, \texttt{ldw}, \texttt{clr} and \texttt{clrw}, and handle the rest with 8-bit \texttt{and}.

Hardware multiplication is costly, so there are no instructions requiring a multiplier wider than 8 times 8 to 16. Instead, the \texttt{mad} instruction is provided for efficient use of the 8 times 8 to 16 multiplier when implementing wider multiplications. Division is less common than multiplication, but complex or costly to implement in hardware.

A \texttt{cpijz acc8, (z), \#d} instruction could speed up \texttt{strlen}, \texttt{strnlen}, \texttt{memchr} and \texttt{memcmp}, but the gain is not as big as for \texttt{ldi} and \texttt{ldwi}. Furthermore, compilers would be unlikely to use \texttt{cpijz} in code generation, unlike \texttt{ldi} and \texttt{ldwi}. So \texttt{cpijz} would only be useful for the mentioned standard library functions.

An atomic bit-swap instruction \texttt{xchb} would not be used often enough to justify having it in addition to \texttt{msk}.


\chapter{Opcode Map}

todo - see opcodemap.ods for now.

\chapter{Peripherals}

Unless otherwise noted, the vlaue of I/O registers on reset is unspecified.

\section{Watchdog and Reset}

The watchdog has an 8-bit configuration register and a 16-bit counter register.

When the watchdog is active, the system clock is divided by 16, and then used to increment the counter register.

The system is reset when a power-on reset happens, the watchdog counter register reaches 0xffff, the trap instruction is executed, or the byte at memory address 0 is written.

\subsection*{Configuration Register}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.13\linewidth]{8}
	\bitheader{0,1,2,3,4,7} \\
	\bitbox{1}{dog active} & \bitbox{1}{dog reset} & \bitbox{1}{trap reset} & \bitbox{1}{null reset} & \bitbox{4}{reserved}
\end{bytefield}

The lowest bit of the configuration register decides if the watchdog is active. It is 0 on reset. The following three bits give the reason of the latest reset. On a power-on-reset they are all 0.

\section{Interrupt Controller}

The interrupt controller has a 16-bit enable register, and a 16-bit active register.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.06\linewidth]{8}
	\bitheader{0,1,15} \\
	\bitbox{1}{t0ov} & \bitbox{1}{t0cp} & \bitbox{14}{reserved}
\end{bytefield}

When an interrupt happens and the corresponding bit in the enable register is set, the corresponding bit in the active register is set. When a bit in the active register is set, and no interrupt routine is currently executing, the program counter is put onto the stack and then set to 0x4004. From then on, an interrupt routine is considered to be executing until the \texttt{reti} instruction is executed.

Bit 0 of the enable register indicates that timer 0 overflow interrupts are enabled. Bit 0 of the active register indicates that a timer0 overflow interrupt is active. Bit 1 of the enable register indicates that timer 0 compare interrupts are enabled. Bit 1 of the active register indicates that a timer 0 compare interrupt is active. These bits are 0 on reset. All other bits are reserved.

\section{Timer}

The timer has an 8-bit configuration register and 16-bit counter, reload and comparison registers.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.13\linewidth]{8}
	\bitheader{0,3,4,5,6,7} \\
	\bitbox{4}{input clock} & \bitbox{2}{prescaler} & \bitbox{2}{reserved}
\end{bytefield}

The lowest 4 bits of the configuration register select the clock source (0 none, 1 system clock, 2 to 15 for other inputs), the next 2 select the prescaler factor (0 for 1, 1 for 4, 2 for 16, 3 for 64). All 6 bits are 0 on reset.

The timer increments the 16-bit counter register. When incrementing from 0xffff, a timer overflow interrupt happens, and the value from the reload register gets loaded into the counter register instead. When the timer register gets incremented to the value of the compare register, a timer compare interrupt happens.

\section{GPIO}

The GPIO has (up to 16 bit) data direction, output data, input data, pull-up registers.

\end{document}

