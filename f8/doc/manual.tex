% -------------------------------------------------------------------------
% manual.tex - f8 manual

% Copyright (c) 2024, Philipp Klaus Krause philipp@colecovision.eu)

% This program is free software; you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation; either version 2, or (at your option) any
% later version.

% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.

% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
% -------------------------------------------------------------------------*/

\documentclass{book}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{makecell}
\usepackage[english]{isodate}
\renewcommand{\cellalign}{tl}

\isodate

\title{f8 manual}
\author{Philipp Klaus Krause}

\begin{document}

\maketitle

\chapter{Architecture}

\section{Introduction}

Little-endian. Stack grows downward. 16-bit flat address space.

\texttt{pc} after reset: 0x4000. Other registers (including \texttt{sp}) after reset: unspecified. (P)ROM/Flash from 0x4000. RAM up to 0x3fff. I/O from 0x0000. Empty PROM/Flash is logically 0x00 (to trigger trap). All instructions execute atomically. Memory reads have no side-effects.

Safety features: trap on opcode 0x00. Trap on write to address 0x0000.

\section{Registers}

There is an 8-bit flag register \texttt{f}, which contains the half-carry flag \texttt{h}, the carry flag \texttt{c}, the negative flag \texttt{n}, the zero flag \texttt{z}, the overflow / parity flag \texttt{o}, and three reserved bits. Unless otherwise noted, instructions leave the reserved flags in an undefined state. The reserved bits should not be written by the user except via the \texttt{xch f, (}n\texttt{, sp)} instruction.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.050\linewidth]{8}
	\bitheader{0,7} \\
	\bitbox{1}{\texttt{h}} & \bitbox{1}{\texttt{c}} & \bitbox{1}{\texttt{n}} & \bitbox{1}{\texttt{z}} & \bitbox{1}{\texttt{o}} & \bitbox{3}{reserved}
\end{bytefield}

\vspace{3mm}
There are a 16-bit program counter \texttt{pc} and a 16-bit stack pointer \texttt{sp}.

\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{pc}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{sp}}
\end{bytefield}

There are three 16-bit general-purpose registers, each consisting of two 8.bit registers.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{x}} \\
	\bitbox{8}{\texttt{xl}} &
	\bitbox{8}{\texttt{xh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{y}} \\
	\bitbox{8}{\texttt{yl}} &
	\bitbox{8}{\texttt{yh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{z}} \\
	\bitbox{8}{\texttt{zl}} &
	\bitbox{8}{\texttt{zh}}
\end{bytefield}

\section{Instructions}

There is the f8 lightweight instruction subset f8l.

Instructions have up to 3 source and up to 2 destination operands. At most one source and one destination operand are in memory.

Each instruction is encoded by 1 to 3 bytes: an optional prefix byte is followed by the opcode byte and 0 to 2 operand bytes.

There are 8 prefix bytes:

\begin{tabular}{l l l}
Prefix & semantics & group \\
\texttt{swapop} & swap operands & 0 \\
\texttt{altacc1} & alternative acumulator \texttt{xh} instead of \texttt{xl} & 1 \\
\texttt{altacc2} & alternative acumulator \texttt{yl} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc4} & alternative acumulator \texttt{yh} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc3} & alternative acumulator \texttt{zl} instead of \texttt{xl}, \texttt{x} instead of \texttt{y} & 2 \\
\texttt{altacc5} & alternative acumulator \texttt{zh} instead of \texttt{xl} & 2
\end{tabular}

\section{Addressing Modes}

\begin{tabular}{l l l}
\texttt{xl}, \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh}, \texttt{f} & 8-bit register \\
\texttt{x}, \texttt{y}, \texttt{z}, \texttt{sp} & 16-bit register \\
\texttt{\#i} & 8-bit immediate \\
\texttt{\#ii} & 16-bit immediate \\
\texttt{\#d} & 8-bit immediate sign-extended to 16 bit \\
\texttt{mm} & direct \\
\texttt{(n, sp)}, \texttt{(n, y)} & indexed with 8-bit offset \\
\texttt{(nn, z)} & indexed with 16-bit offset \\
\texttt{(x)}, \texttt{(y)}, \texttt{(z)} & indirect
\end{tabular}


\chapter{Instructions}

\begin{tabular}{l l l}
\texttt{op8\_2} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{\#i}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{op8\_2ni} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{altacc8} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh}. \\
\texttt{op16\_2} & Any of \texttt{x}, \texttt{\#ii}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{op16\_2ni} & Any of \texttt{x}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{altacc16} & Any of \texttt{x}, \texttt{z}. \\
\texttt{op8\_1} & Any of \texttt{xl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(n, y)}. \\
\texttt{op16\_1} & Any of \texttt{y}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\end{tabular}

\section{8-bit two-operand instructions}

Instructions where the location is used for \texttt{altacc8} and \texttt{op8} are not valid.

\subsection{adc: 8-bit addition with carry}

\begin{tabular}{l l l}
Assembler code            & Operation                                  & f8l \\
\texttt{adc xl, op8\_2}      & \texttt{xl = xl + op8\_2 + c}           & Yes \\
\texttt{adc altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2 + c} & Yes \\
\texttt{adc op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni + xl + c}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{add: 8-bit addition}

\begin{tabular}{l l l}
Assembler code            & Operation                              & f8l \\
\texttt{add xl, op8\_2}      & \texttt{xl = xl + op8\_2}           & Yes \\
\texttt{add altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2} & Yes \\
\texttt{add op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + xl} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{and: 8-bit bitwise and}

\begin{tabular}{l l l}
Assembler code               & Operation                            & f8l \\
\texttt{and xl, op8\_2}      & \texttt{xl = xl \& op8\_2}           & Yes \\
\texttt{and altacc8, op8\_2} & \texttt{altacc8 = altacc8 \& op8\_2} & Yes \\
\texttt{and op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \& xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{cp: 8-bit comparison}

Subtraction where the result is used to update the flags only.

\begin{tabular}{l l l}
Assembler code              & Operation                      & f8l\\
\texttt{cp xl, op8\_2}      & \texttt{xl + \~{}op8\_2 + 1}      & Yes \\
\texttt{cp altacc8, op8\_2} & \texttt{altacc8 + \~{}op8\_2 + 1} & Yes \\
\texttt{cp op8\_2, xl}      & \texttt{op8\_2 + \~{}xl + 1}      & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{or: 8-bit bitwise or}

\begin{tabular}{l l l}
Assembler code              & Operation                           & f8l \\
\texttt{or xl, op8\_2}      & \texttt{xl = xl | op8\_2}           & Yes \\
\texttt{or altacc8, op8\_2} & \texttt{altacc8 = altacc8 | op8\_2} & Yes \\
\texttt{or op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni | xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{sbc: 8-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code                 & Operation                                  & f8l \\
\texttt{sbc xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + c}           & Yes \\
\texttt{sbc altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + c} & Yes \\
\texttt{sbc op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + c}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{sub: 8-bit subtraction}

\begin{tabular}{l l l}
Assembler code                 & Operation                                  & f8l \\
\texttt{sub xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + 1}           & Yes \\
\texttt{sub altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + 1} & Yes \\
\texttt{sub op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + 1}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{xor: 8-bit bitwise exclusive or}

\begin{tabular}{l l l}
Assembler code               & Operation                              & f8l \\
\texttt{xor xl, op8\_2}      & \texttt{xl = xl \^{} op8\_2}           & Yes \\
\texttt{xor altacc8, op8\_2} & \texttt{altacc8 = altacc8 \^{} op8\_2} & Yes \\
\texttt{xor op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \^{} xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\section{16-bit 2-operand-instructions}

Todo: Document possible altacc prefixes.

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                              & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2 + c}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{addw: 16 bit addition}

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{orw: 16 bit bitwise or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code             & Operation                          & f8l \\
\texttt{orw xl, op16\_2}   & \texttt{y = y | op16\_2}           & No \\
\texttt{orw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni | y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\subsection{sbcw: 16 bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{sbcw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + c}       & No \\
\texttt{sbcw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{subw: 16 bit subtraction}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{subw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + 1}       & No \\
\texttt{subw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + 1} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{xorw: 16 bit bitwise exclusive or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{xorw xl, op16\_2}   & \texttt{y = y \^{} op16\_2}           & No \\
\texttt{xorw op16\_2ni, xl} & \texttt{op16\_ni2 = op16\_2ni \^{} y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\section{8-bit 1-operand-instructions}

\subsection{clr: 8-bit clear}

\begin{tabular}{l l l}
Assembler code       & Operation               & f8l \\
\texttt{clr op8\_1}  & \texttt{op8 = 0x00}     & Yes, except (n, y) \\
\texttt{clr altacc8} & \texttt{altacc8 = 0x00} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{dec: 8-bit decrement}

\begin{tabular}{l l l}
Assembler code       & Operation                       & f8l \\
\texttt{dec op8\_1}  & \texttt{op8 = op8 + -1}         & Yes, except (n, y) \\
\texttt{dec altacc8} & \texttt{altacc8 = altacc8 + -1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{inc: 8-bit increment}

\begin{tabular}{l l l}
Assembler code       & Operation                      & f8l \\
\texttt{inc op8\_1}  & \texttt{op8 = op8 + 1}         & Yes, except (n, y) \\
\texttt{inc altacc8} & \texttt{altacc8 = altacc8 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{push: 8-bit push onto stack}

\begin{tabular}{l l l}
Assembler code        & Operation                 & f8l \\
\texttt{push op8\_1}  & \texttt{(--sp) = op8}     & Yes, except (n, y) \\
\texttt{push altacc8} & \texttt{(--sp) = altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{sll: 8-bit shift left logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                   & f8l \\
\texttt{sll op8\_1}  & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{op8 = op8 << 1}}         & Yes, except (n, y) \\
\texttt{sll altacc8} & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{altacc8 = altacc8 << 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{srl: 8-bit shift right logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                            & f8l \\
\texttt{srl op8\_1}  & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{op8 = op8 >> 1}}         & Yes (except (n, y) \\
\texttt{srl altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = altacc8 >> 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{rlc: 8-bit rotate left through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rlc op8\_1}  & \makecell{\texttt{tc = (op8  \& 0x80) >> 7}\\\texttt{op8 = (op8 << 1) | c}\\\texttt{c = tc}}            & Yes (except (n, y) \\
\texttt{rlc altacc8} & \makecell{\texttt{tc = (altacc8 \& 0x80) >> 7}\\\texttt{altacc8 = (altacc8 << 1) | c}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{rrc: 8-bit rotate right through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rrc op8\_1}  & \makecell{\texttt{tc = op8  \& 0x01}\\\texttt{op8 = (op8 >> 1) | (c << 7)}\\\texttt{c = tc}}            & Yes (except (n, y) \\
\texttt{rrc altacc8} & \makecell{\texttt{tc = altacc8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | (c << 7)}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{tst: 8-bit test}

Set n and z flags according to value of operand, o flag by parity, reset c.

\begin{tabular}{l l l}
Assembler code       & Operation        & f8l \\
\texttt{tst op8\_1}  & \texttt{op8}     & Yes (except (n, y) \\
\texttt{tst altacc8} & \texttt{altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\section{16-bit 1-operand-instructions}

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{adcw op16\_1}  & \texttt{op16 = op16 + c}         & No \\
\texttt{adcw altacc16} & \texttt{altacc16 = altacc16 + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{clrw: 16-bit clear}

\begin{tabular}{l l l}
Assembler code         & Operation                  & f8l \\
\texttt{clrw op16\_1}  & \texttt{op16 = 0x0000}     & Yes \\
\texttt{clrw altacc15} & \texttt{altacc16 = 0x0000} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{incw: 16-bit increment}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{incw op16\_1}  & \texttt{op16 = op16 + 1}         & Yes \\
\texttt{incw altacc16} & \texttt{altacc16 = altacc16 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code          & Operation                         & f8l \\
\texttt{pushw op16\_1}  & \texttt{sp -= 2; (sp) = op16}     & Yes \\
\texttt{pushw altacc16} & \texttt{sp -= 2; (sp) = altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{sbcw: 16-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                 & f8l \\
\texttt{sbcw op16\_1}  & \texttt{op16 = op16 + 0xffff + c}         & No \\
\texttt{sbcw altacc16} & \texttt{altacc16 = altacc16 + 0xffff + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{tstw: 16-bit test}

Set n and z flags according to value of operand, o flag by parity, set c.

\begin{tabular}{l l l}
Assembler code         & Operation         & f8l \\
\texttt{tstw op16\_1}  & \texttt{op16}     & Yes \\
\texttt{tstw altacc16} & \texttt{altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\section{8-bit loads}

\subsection{ld: 8-bit load from memory}

\begin{tabular}{l l l}
Assembler code                  & Operation                     & f8l \\
\texttt{ld xl, \#i}             & \texttt{xl = \#i}             & Yes \\
\texttt{ld altacc8, \#i}        & \texttt{altacc8 = \#i}        & Yes \\
\texttt{ld xl, mm}              & \texttt{xl = mm}              & Yes \\
\texttt{ld altacc8, mm}         & \texttt{altacc8 = mm}         & Yes \\
\texttt{ld xl, (n, sp)}         & \texttt{xl = (n, sp)}         & Yes \\
\texttt{ld altacc8, (n, sp)}    & \texttt{altacc8 = (n, sp)}    & Yes \\
\texttt{ld xl, (nn, z)}         & \texttt{xl = (nn, z)}         & Yes \\
\texttt{ld altacc8, (nn, z)}    & \texttt{altacc8 = (nn, z)}    & Yes \\
\texttt{ld xl, (y)}             & \texttt{xl = xh}              & Yes \\
\texttt{ld altacc8, (altacc16)} & \texttt{altacc8 = (altacc16)} & Yes \\
\texttt{ld xl, (n, y)}          & \texttt{xl = (n, y)}          & No \\
\texttt{ld altacc8, (n, y)}     & \texttt{altacc8 = (n, y)}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{ld: 8-bit load from register}

\begin{tabular}{l l l}
Assembler code                  & Operation                     & f8l \\
\texttt{ld xl, xh}              & \texttt{xl = xh}              & Yes \\
\texttt{ld xh, xl}              & \texttt{xh = xl}              & Yes \\
\texttt{ld altacc8, xh}         & \texttt{altacc8 = xh}         & Yes \\
\texttt{ld xl, yl}              & \texttt{xl = yl}              & Yes \\
\texttt{ld yl, xl}              & \texttt{yl = xl}              & Yes \\
\texttt{ld altacc8, yl}         & \texttt{altacc8 = yl}         & Yes \\
\texttt{ld xl, yh}              & \texttt{xl = yh}              & Yes \\
\texttt{ld yh, xl}              & \texttt{yh = xl}              & Yes \\
\texttt{ld altacc8, yh}         & \texttt{altacc8 = yh}         & Yes \\
\texttt{ld xl, zl}              & \texttt{xl = zl}              & Yes \\
\texttt{ld zl, xl}              & \texttt{zl = xl}              & Yes \\
\texttt{ld altacc8, zl}         & \texttt{altacc8 = zl}         & Yes \\
\texttt{ld xl, zh}              & \texttt{xl = zh}              & Yes \\
\texttt{ld zh, xl}              & \texttt{zh = xl}              & Yes \\
\texttt{ld altacc8, zh}         & \texttt{altacc8 = zh}         & Yes \\
\texttt{ld mm, xl}              & \texttt{mm = xl}              & Yes \\
\texttt{ld mm, altacc8}         & \texttt{mm = altacc8}         & Yes \\
\texttt{ld (n, sp), xl}         & \texttt{(n, sp) = xl}         & Yes \\
\texttt{ld (n, sp), altacc8}    & \texttt{(n, sp) = altacc8}    & Yes \\
\texttt{ld (nn, z), xl}         & \texttt{(nn, z) = altacc8}    & Yes \\
\texttt{ld (nn, z), altacc8}    & \texttt{(nn, z) = altacc8}    & Yes \\
\texttt{ld (y), xl}             & \texttt{(y) = xl}             & Yes \\
\texttt{ld (altacc16), altacc8} & \texttt{(altacc16) = altacc8} & Yes \\
\texttt{ld (n, y), xl}          & \texttt{(n, y) = xl}          & No \\
\texttt{ld (n, y), altacc8}     & \texttt{(n, y) = altacc8}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{ldi: 8-bit load with increment}

Flags according to old (y).

\begin{tabular}{l l l}
Assembler code        & Operation                   & f8l \\
\texttt{ldi (y), (z)} & \texttt{(y) = (z); z += 1;} & No \\
\texttt{ldi (x), (z)} & \texttt{(x) = (z); z += 1;} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\section{16-bit loads}

\subsection{ldw: 16-bit load from memory}

\begin{tabular}{l l l}
Assembler code                    & Operation                      & f8l \\
\texttt{ldw y, \#ii}              & \texttt{y = \#ii}              & Yes \\
\texttt{ldw altacc16, \#ii}       & \texttt{altacc16 = \#ii}       & Yes \\
\texttt{ldw y, mm}                & \texttt{y = mm}                & Yes \\
\texttt{ldw altacc16, mm}         & \texttt{altacc16 = mm}         & Yes \\
\texttt{ldw y, (n, sp)}           & \texttt{y = (n, sp)}           & Yes \\
\texttt{ldw altacc16, (n, sp)}    & \texttt{altacc16 = (n, sp)}    & Yes \\
\texttt{ldw y, (nn, z)}           & \texttt{y = (nn, z)}           & Yes \\
\texttt{ldw altacc16, (nn, z)}    & \texttt{altacc16 = (nn, z)}    & Yes \\
\texttt{ldw y, (n, y)}            & \texttt{y = (n, y)}            & No \\
\texttt{ldw altacc16, (n, y)}     & \texttt{altacc16 = (n, y)}     & No \\
\texttt{ldw y, (y)}               & \texttt{y = (y)}               & Yes \\
\texttt{ldw altacc16, (altacc16)} & \texttt{altacc16 = (altacc16)} & Yes \\
\texttt{ldw y, \#d}               & \texttt{y = \#d}               & Yes \\
\texttt{ldw altacc16, \#d}        & \texttt{altacc16 = \#d}        & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{ldw 16-bit load from register}

\begin{tabular}{l l l}
Assembler code                   & Operation                   & f8l \\
\texttt{ldw y, x}                & \texttt{y = x}              & Yes \\
\texttt{ldw y, z}                & \texttt{x = z}              & Yes \\
\texttt{ldw z, x}                & \texttt{x = z}              & Yes \\
\texttt{ldw x, z}                & \texttt{x = z}              & Yes \\
\texttt{ldw mm, y}               & \texttt{mm = y}             & Yes \\
\texttt{ldw mm, altacc16}        & \texttt{mm = altacc16}      & Yes \\
\texttt{ldw (n, sp), y}          & \texttt{(n, sp) = y}        & Yes \\
\texttt{ldw (n, sp), altacc16}   & \texttt{(n, sp) = altacc16} & Yes \\
\texttt{ldw (nn, z), y}          & \texttt{(nn, z) = y}        & Yes \\
\texttt{ldw (nn, z), altacc16}   & \texttt{(nn, z) = altacc16} & Yes \\
\texttt{ldw x, y}                & \texttt{x = y}              & Yes \\
\texttt{ldw z, y}                & \texttt{z = y}              & Yes \\
\texttt{ldw y, z}                & \texttt{y = z}              & Yes \\
\texttt{ldw z, x}                & \texttt{z = x}              & Yes \\
\texttt{ldw (y), x}              & \texttt{(y) = x}            & Yes \\
\texttt{ldw (z), y}              & \texttt{(z) = y}            & Yes \\
\texttt{ldw (x), z}              & \texttt{(x) = z}            & Yes \\
\texttt{ldw (y), z}              & \texttt{(y) = z}            & Yes \\
\texttt{ldw (n, y), x}           & \texttt{(n, y) = x}         & No \\
\texttt{ldw y, sp}               & \texttt{y = sp}             & Yes \\
\texttt{ldw sp, y}               & \texttt{sp = y}             & Yes \\
\texttt{ldw altacc16, sp}        & \texttt{altacc16 = sp}      & Yes \\
\texttt{ldw ((d, sp)), y}        & \texttt{(d, sp) = y}        & No \\
\texttt{ldw ((d, sp)), altacc16} & \texttt{(d, sp) = altacc16} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{ldwi: 16-bit load with increment}

Flags according to old (y).

\begin{tabular}{l l l}
Assembler code         & Operation                   & f8l \\
\texttt{ldwi (y), (z)} & \texttt{(y) = (z); z += 2;} & No \\
\texttt{ldwi (x), (z)} & \texttt{(x) = (z); z += 2;} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{sex: sign-extend}

\begin{tabular}{l l l}
Assembler code                 & Operation                            & f8l \\
\texttt{sex y, xl}             & \texttt{y = (int8\_t)xl}             & No \\
\texttt{sex altacc16, altacc8} & \texttt{altacc16 = (int8\_t)altacc8} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{zex: zero-extend}

\begin{tabular}{l l l}
Assembler code                 & Operation                   & f8l \\
\texttt{zex y, xl}             & \texttt{y = xl}         & No \\
\texttt{zex altacc16, altacc8} & \texttt{altacc16 = altacc8} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\section{Other 8-bit instructions}

\subsection{bool: 8-bit cast to bool}

Todo: Remove from f8l subset?

\begin{tabular}{l l l}
Assembler code        & Operation                        & f8l \\
\texttt{bool xl}      & \texttt{xl = (bool)xl}           & Yes \\
\texttt{bool altacc8} & \texttt{altacc8 = (bool)altacc8} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{cax: 8-bit compare and exchange}

z is set according to the old value of (y) - zl.

\begin{tabular}{l l l}
Assembler code            & Operation                                        & f8l \\
\texttt{cax (y), zl, xl}  & \texttt{if ((y) == zl) (y) = xl; else zl = (y);} & Yes \\
\texttt{cax (y), zl, xh}  & \texttt{if ((y) == zl) (y) = xh; else zl = (y);} & Yes \\
\texttt{cax (y), zl, zh}  & \texttt{if ((y) == zl) (y) = zh; else zl = (y);} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{da: decimal adjust}

Decimal adjust for addition / subtraction - binary coded decimal semantics.

todo: describe details!

\begin{tabular}{l l l}
Assembler code       & Operation & f8l \\
\texttt{da xl}      &           & Yes \\
\texttt{da altacc8} &           & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{mad: multiply and add}

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{mad x, mm, yl}      & \texttt{x = mm * yl + xh + c}      & No \\
\texttt{mad x, (n, sp), yl} & \texttt{x = (n, sp) * yl + xh + c} & No \\
\texttt{mad x, (nn, z), yl} & \texttt{x = (nn, z) * yl + xh + c} & No \\
\texttt{mad x, (z), yl}     & \texttt{x = (z) * yl + xh + c}     & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{msk: mask}

z flag set according to old value of  (y) \& \#i.

\begin{tabular}{l l l}
Assembler code                        & Operation                                                    & f8l \\
\texttt{msk (y), xl, \#i}             & \texttt{(y) = xl \& \#i | (y) \& \~{}\#i}                    & Yes \\
\texttt{msk (altacc16), altacc8, \#i} & \texttt{(altacc16) = altacc8 \& \#i | (altacc16) \& \~{}\#i} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}

\subsection{pop: 8-bit pop from stack}

\begin{tabular}{l l l}
Assembler code       & Operation                 & f8l \\
\texttt{pop xl}      & \texttt{xl = (sp++)}      & Yes \\
\texttt{pop altacc8} & \texttt{altacc8 = (sp++)} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{push: 8-bit push onto stack}

Ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code    & Operation             & f8l \\
\texttt{push \#i} & \texttt{(--sp) = \#i} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{rot: 8-bit rotate}

\begin{tabular}{l l l}
Assembler code            & Operation                                                    & f8l \\
\texttt{rot xl, \#i}      & \texttt{xl = (xl << \#i) | (xl >> (8 - \#i))}                & No \\
\texttt{rot altacc8, \#i} & \texttt{altacc8 = (altacc8 << \#i) | (altacc8 >> (8 - \#i))} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{sra: 8-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                               & f8l \\
\texttt{sra xl}      & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{xl = (xl >> 1) | xl \& 0x80}}               & Yes \\
\texttt{sra altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | altacc \& 0x80}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{thrd}

Get current hardware thread number.

\begin{tabular}{l l l}
Assembler code        & Operation                                         & f8l \\
\texttt{thrd xl}      & \texttt{xl =} current hardware thread number      & Yes \\
\texttt{thrd altacc8} & \texttt{altacc8 =} current hardware thread number & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{xch: 8-bit exchange}

\begin{tabular}{l l l}
Assembler code                   & Operation                                                  & f8l \\
\texttt{xch yl, yh}              & \texttt{t = yl; yl = yh; yh = t}                           & Yes \\
\texttt{xch xl, xh}              & \texttt{t = xl; xl = xh; xh = t}                           & Yes \\
\texttt{xch zl, zh}              & \texttt{t = zl; zl = zh; zh = t}                           & Yes \\
\texttt{xch xl, (n, sp)}         & \texttt{t = (n, sp); (n, sp) = xl; xl = t}                 & No \\
\texttt{xch altacc8, (n, sp)}    & \texttt{t = (n, sp); (n, sp) = altacc8; altacc8 = t}       & No \\
\texttt{xch xl, (y)}             & \texttt{t = (y); (y) = xl; xl = t}                         & Yes \\
\texttt{xch altacc8, (altacc16)} & \texttt{t = (altacc16); (altacc16) = altacc8; altacc8 = t} & Yes \\
\texttt{xch f, (n, sp)}          & \texttt{t = (n, sp); (n, sp) = f; f = t}                   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

All, including reserved ones (\texttt{xch f, (n, sp)}) or none (all others).

\section{Other 16-bit instructions}

\subsection{addw: 16-bit addition}

\texttt{addw sp, \#d} ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{addw sp, \#d}       & \texttt{sp = sp + \#d}             & Yes \\
\texttt{addw y, \#d}        & \texttt{y = y + \#d}               & Yes \\
\texttt{addw altacc16, \#d} & \texttt{altacc16 = altacc16 + \#d} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none (\texttt{addw sp, \#d}) or \texttt{cnzo} (all others).


\subsection{boolw: 16-bit cast to bool}

\begin{tabular}{l l l}
Assembler code          & Operation                          & f8l \\
\texttt{boolw y}        & \texttt{y = (bool)y}               & No \\
\texttt{boolw altacc16} & \texttt{altacc16 = (bool)altacc16} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{caxw: 16-bit compare and exchange}

z is set according to the old value of (y) - z.

\begin{tabular}{l l l}
Assembler code           & Operation                                     & f8l \\
\texttt{caxw (y), z, x}  & \texttt{if ((y) == z) (y) = x; else z = (y);} & Yes \\

\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{cpw: 16-bit comparison}

Subtraction where the result is used to update the flags only.

\begin{tabular}{l l l}
Assembler code              & Operation                        & f8l\\
\texttt{cpw y, \#ii}        & \texttt{y + \~{}\#ii + 1}        & No \\
\texttt{cpw \#ii, y}        & \texttt{\#ii + \~{}y + 1}        & No \\
\texttt{cpw altacc16, \#ii} & \texttt{altacc16 + \~{}\#ii + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{decw: 16-bit decrement}

\begin{tabular}{l l l}
Assembler code        & Operation                       & f8l \\
\texttt{decw (n, sp)} & \texttt{(n, sp) = (n, sp) + -1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{incnw: 16-bit increment without carry update}

Ignores all flags, changes no flags (except possibly the reserved ones).

\begin{tabular}{l l l}
Assembler code          & Operation                        & f8l \\
\texttt{incnw y}        & \texttt{y = y + 1}               & No \\
\texttt{incnw altacc16} & \texttt{altacc16 = altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{negw: 16-bit negation}

\begin{tabular}{l l l}
Assembler code         & Operation                            & f8l \\
\texttt{negw y}        & \texttt{y = \~{}y + 1}               & No \\
\texttt{negw altacc16} & \texttt{altacc16 = \~{}altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{mul: multiplication}

Clears carry.

\begin{tabular}{l l l}
Assembler code & Operation            & f8l \\
\texttt{mul y} & \texttt{y = yl * yh} & No \\
\texttt{mul x} & \texttt{x = xl * xh} & No \\
\texttt{mul z} & \texttt{z = zl * zh} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{popw: 16-bit pop from stack}

\begin{tabular}{l l l}
Assembler code         & Operation                         & f8l \\
\texttt{popw y}        & \texttt{y = (sp); sp += 2}        & Yes \\
\texttt{popw altacc16} & \texttt{altacc16 = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code      & Operation                     & f8l \\
\texttt{pushw \#ii} & \texttt{sp -= 2; (sp) = \#ii} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{rlcw: 16-bit rotate left through carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                                                                                             & f8l \\
\texttt{rlcw y}        & \makecell{\texttt{tc = (y \& 0x8000) >> 15}\\\texttt{y = (y >> 1) | (c << 15)}\\\texttt{c = tc}}                      & No \\
\texttt{rlcw (n, sp)}  & \makecell{\texttt{tc = ((n, sp) \& 0x8000) >> 15}\\\texttt{(n, sp) = ((n, sp) >> 1) | (c << 15)}\\\texttt{c = tc}}    & No \\
\texttt{rlcw altacc16} & \makecell{\texttt{tc = (altacc16 \& 0x8000) >> 15}\\\texttt{altacc16 = (altacc16 >> 1) | (c << 15)}\\\texttt{c = tc}} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{rrcw: 16-bit rotate right through carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                                                                                   & f8l \\
\texttt{rrcw y}        & \makecell{\texttt{tc = y \& 0x0001}\\\texttt{y = (y >> 1) | c}\\\texttt{c = tc}}                    & No \\
\texttt{rrcw (n, sp)}  & \makecell{\texttt{tc = (n, sp) \& 0x0001}\\\texttt{(n, sp) = ((n, sp) << 1) | c}\\\texttt{c = tc}}  & No \\
\texttt{rrcw altacc16} & \makecell{\texttt{tc = altacc16 \& 0x0001}\\\texttt{altacc16 = (altacc16 << 1) | c}\\\texttt{c = tc}} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{sllw: 16-bit shift left logical}

\begin{tabular}{l l l}
Assembler code                  & Operation                                     & f8l \\
\texttt{sllw y}                 & \texttt{c = y \& (0x8000 >> 15); y = y << 1}  & No \\
\texttt{sllw altacc16}          & \texttt{altacc16 = altacc16 << 1}             & No \\
\texttt{sllw y, xl}             & \texttt{c = y \& (0x8000 >> 15); y = y << xl} & No \\
\texttt{sllw altacc16, altacc8} & \texttt{altacc16 = altacc16 << altacc8}       & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz} (\texttt{sllw y} and \texttt{sllw altacc16}) or \texttt{nz} (others).


\subsection{sraw: 16-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code         & Operation                                                               & f8l \\
\texttt{sraw y}        & \texttt{c = y \& 0x0001; y = y >> 1 | y \& 0x8000}                      & No \\
\texttt{sraw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1 | altacc16 \& 0x8000} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsection{srlw: 16-bit shift right logical}

\begin{tabular}{l l l}
Assembler code         & Operation                                          & f8l \\
\texttt{srlw y}        & \texttt{c = y \& 0x0001; y = y >> 1}               & No \\
\texttt{srlw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{xchw: 16-bit exchange}

\begin{tabular}{l l l}
Assembler code                  & Operation                                              & f8l \\
\texttt{xchw x, (y)}            & \texttt{t = x; x = (y); (y) = t}                       & Yes \\
\texttt{xchw y, (z)}            & \texttt{t = y; y = (z); (z) = t}                       & Yes \\
\texttt{xchw z, (x)}            & \texttt{t = z; z = (x); (x) = t}                       & Yes \\
\texttt{xchw z, (y)}            & \texttt{t = z; z = (y); (y) = t}                       & Yes \\
\texttt{xchw y, (n, sp)}        & \texttt{t = y; y = (n, sp); (n, sp) = t}               & No \\
\texttt{xchw altacc16, (n, sp)} & \texttt{t = altacc16; altacc16 = (n, sp); (n, sp) = t} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsubsection*{Affected Flags}

\texttt{z}


\section{Jumps}

\subsection{call}

\begin{tabular}{l l l}
Assembler code         & Operation                                  & f8l \\
\texttt{call \#ii}     & \texttt{sp -= 2; (sp) = pc; pc = \#ii}     & Yes \\
\texttt{call y}        & \texttt{sp -= 2; (sp) = pc; pc = y}        & Yes \\
\texttt{call altacc16} & \texttt{sp -= 2; (sp) = pc; pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{dnjnz: decrement without carry update amd jump if not zero}

\begin{tabular}{l l l}
Assembler code         & Operation          & f8l \\
\texttt{dnjnz yh, \#d} & \texttt{if(--yh) pc += \#d} & No \\
\texttt{dnjnz xh, \#d} & \texttt{if(--xh) pc += \#d} & No \\
\texttt{dnjnz zh, \#d} & \texttt{if(--zh) pc += \#d} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jp: jump}

\texttt{jp \#ii} ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code       & Operation              & f8l \\
\texttt{jp \#ii}     & \texttt{pc = \#ii}     & Yes \\
\texttt{jp y}        & \texttt{pc = y}        & Yes \\
\texttt{jp altacc16} & \texttt{pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{jr: jump}

\texttt{jr \#d} ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code  & Operation          & f8l \\
\texttt{jr \#d} & \texttt{pc += \#d} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrc: jump on carry}

\begin{tabular}{l l l}
Assembler code  & Operation                  & f8l \\
\texttt{jr \#d} & \texttt{if (c) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrgt: jump on greater}

\begin{tabular}{l l l}
Assembler code    & Operation                        & f8l \\
\texttt{jrgt \#d} & \texttt{if (c \&\& !z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{jrle: jump on less or equal}

\begin{tabular}{l l l}
Assembler code    & Operation                        & f8l \\
\texttt{jrle \#d} & \texttt{if (!c || z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrn: jump on negative}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jrn \#d} & \texttt{if (n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrnc: jump on no carry}

\begin{tabular}{l l l}
Assembler code    & Operation                    & f8l \\
\texttt{jrnc \#d} & \texttt{if (!c) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrnn: jump on nonnegative}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrnn \#d} & \texttt{if (!n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrno: jump on no overflow}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrno \#d} & \texttt{if (!o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrnz: jump on nonzero}

\begin{tabular}{l l l}
Assembler code    & Operation                   & f8l \\
\texttt{jrnz \#d} & \texttt{if (!n) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jro: jump on overflow}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jro \#d} & \texttt{if (o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrsge: jump on signed greater or equal}

\begin{tabular}{l l l}
Assembler code     & Operation                            & f8l \\
\texttt{jrsge \#d} & \texttt{if (!(n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrsgt: jump on signed greater}

\begin{tabular}{l l l}
Assembler code     & Operation                            & f8l \\
\texttt{jrsgt \#d} & \texttt{if (!z \&\& !(n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{jrsle: jump on signed less or equal}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jrsle \#d} & \texttt{if (z || (n \^{} o)) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrslt: jump on signed less}

\begin{tabular}{l l l}
Assembler code     & Operation                         & f8l \\
\texttt{jrslt \#d} & \texttt{if (n \^{} o) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jrz: jump on zero}

\begin{tabular}{l l l}
Assembler code   & Operation                  & f8l \\
\texttt{jrz \#d} & \texttt{if (z) pc += \#d;} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{ret: return}

\begin{tabular}{l l l}
Assembler code & Operation                   & f8l \\
\texttt{ret}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{reti: return from interrupt}

Ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code  & Operation                   & f8l \\
\texttt{reti}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{trap}

Opcode 0x00. Trap reset.

\begin{tabular}{l l l}
Assembler code  & Operation  & f8l \\
\texttt{trap}   & Trap reset & Yes \\
\end{tabular}


\chapter{Opcode Map}

todo - see opcodemap.ods for now.

\chapter{Peripherals}

Unless otherwise noted, the vlaue of I/O registers on reset is unspecified.

\section{Watchdog and Reset}

The watchdog has an 8-bit configuration register and a 16-bit counter register.

When the watchdog is active, the system clock is divided by 16, and then used to increment the counter register.

The system is reset when a power-on reset happens, the watchdog counter register reaches 0xffff, the trap instruction is executed, or the byte at memory address 0 is written.

\subsection*{Configuration Register}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.13\linewidth]{8}
	\bitheader{0,1,2,3,4,7} \\
	\bitbox{1}{dog active} & \bitbox{1}{dog reset} & \bitbox{1}{trap reset} & \bitbox{1}{null reset} & \bitbox{4}{reserved}
\end{bytefield}

The lowest bit of the configuration register decides if the watchdog is active. It is 0 on reset. The following three bits give the reason of the latest reset. On a power-on-reset they are all 0.

\section{Interrupt Controller}

The interrupt controller has a 16-bit enable register, and a 16-bit active register.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.06\linewidth]{8}
	\bitheader{0,1,15} \\
	\bitbox{1}{t0ov} & \bitbox{1}{t0cp} & \bitbox{14}{reserved}
\end{bytefield}

When an interrupt happens and the corresponding bit in the enable register is set, the corresponding bit in the active register is set. When a bit in the active register is set, and no interrupt routine is currently executing, the program counter is put onto the stack and then set to 0x4004. From then on, an interrupt routine is considered to be executing until the \texttt{reti} instruction is executed.

Bit 0 of the enable register indicates that timer 0 overflow interrupts are enabled. Bit 0 of the active register indicates that a timer0 overflow interrupt is active. Bit 1 of the enable register indicates that timer 0 compare interrupts are enabled. Bit 1 of the active register indicates that a timer 0 compare interrupt is active. These bits are 0 on reset. All other bits are reserved.

\section{Timer}

The timer has an 8-bit configuration register and 16-bit counter, reload and comparison registers.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.13\linewidth]{8}
	\bitheader{0,3,4,5,6,7} \\
	\bitbox{4}{input clock} & \bitbox{2}{prescaler} & \bitbox{2}{reserved}
\end{bytefield}

The lowest 4 bits of the configuration register select the clock source (0 none, 1 system clock, 2 to 15 for other inputs), the next 2 select the prescaler factor (0 for 1, 1 for 4, 2 for 16, 3 for 64). All 6 bits are 0 on reset.

The timer increments the 16-bit counter register. When incrementing from 0xffff, a timer overflow interrupt happens, and the value from the reload register gets loaded into the counter register instead. When the timer register gets incremented to the value of the compare register, a timer compare interrupt happens.

\section{GPIO}

The GPIO has (up to 16 bit) data direction, output data, input data, pull-up registers.

\end{document}

