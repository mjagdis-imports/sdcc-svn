\documentclass{book}
\usepackage{bytefield}
\usepackage{hyperref}
\usepackage{makecell}
\renewcommand{\cellalign}{tl}

\title{f8 Manual}
\author{Philipp Klaus Krause}

\begin{document}

\maketitle

\chapter{Architecture}

\section{Introduction}

Little-endian. Stack grows downward. 16-bit flat address space.

\texttt{pc} after reset: 0x4000. Other registers (including \texttt{sp}) after reset: unspecified. (P)ROM/Flash from 0x4000. RAM up to 0x3fff. I/O from 0x0000. Empty PROM/Flash is logically 0x00 (to trigger trap). All instructions execute atomically.

Safety features: trap on opcode 0x00. Trap on write to address 0x0000.

\section{Registers}

There is an 8-bit flag register \texttt{f}, which contains the half-carry flag \texttt{h}, the carry flag \texttt{c}, the negative flag \texttt{n}, the zero flag \texttt{z}, the overflow / parity flag \texttt{o}, and three reserved bits. Unless otherwise noted, instructions leave the reserved flags in an undefined state. The reserved bits should not be written by the user except via the \texttt{xch f, (}n\texttt{, sp)} instruction.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.050\linewidth]{8}
	\bitheader{0,7} \\
	\bitbox{1}{\texttt{h}} & \bitbox{1}{\texttt{c}} & \bitbox{1}{\texttt{n}} & \bitbox{1}{\texttt{z}} & \bitbox{1}{\texttt{o}} & \bitbox{3}{reserved}
\end{bytefield}

\vspace{3mm}
There are a 16-bit program counter \texttt{pc} and a 16-bit stack pointer \texttt{sp}.

\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{pc}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,15} \\
	\wordbox{1}{\texttt{sp}}
\end{bytefield}

There are three 16-bit general-purpose registers, each consisting of two 8.bit registers.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{x}} \\
	\bitbox{8}{\texttt{xl}} &
	\bitbox{8}{\texttt{xh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{y}} \\
	\bitbox{8}{\texttt{yl}} &
	\bitbox{8}{\texttt{yh}}
\end{bytefield}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.025\linewidth]{16}
	\bitheader{0,7,8,15} \\
	\wordbox{1}{\texttt{z}} \\
	\bitbox{8}{\texttt{zl}} &
	\bitbox{8}{\texttt{zh}}
\end{bytefield}

\section{Instructions}

There is the f8 lightweight instruction subset f8l.

Instructions have up to 3 source and up to 2 destination operands. At most one source and one destination operand are in memory.

Each instruction is encoded by 1 to 3 bytes: an optional prefix byte is followed by the opcode byte and 0 to 2 operand bytes.

There are 8 prefix bytes:

\begin{tabular}{l l l}
Prefix & semantics & group \\
\texttt{swapop} & swap operands & 0 \\
\texttt{altacc1} & alternative acumulator \texttt{xh} instead of \texttt{xl} & 1 \\
\texttt{altacc2} & alternative acumulator \texttt{yl} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc4} & alternative acumulator \texttt{yh} instead of \texttt{xl}, \texttt{z} instead of \texttt{y} & 2 \\
\texttt{altacc3} & alternative acumulator \texttt{zl} instead of \texttt{xl}, \texttt{x} instead of \texttt{y} & 2 \\
\texttt{altacc5} & alternative acumulator \texttt{zh} instead of \texttt{xl} & 2
\end{tabular}

\section{Addressing Modes}

\begin{tabular}{l l l}
\texttt{xl}, \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh} & 8-bit register \\
\texttt{x}, \texttt{y}, \texttt{z}, \texttt{sp} & 16-bit register \\
\texttt{\#i} & 8-bit immediate \\
\texttt{\#ii} & 16-bit immediate \\
\texttt{\#d} & 8-bit immediate sign-extended to 16 bit \\
\texttt{mm} & direct \\
\texttt{(n, sp)}, \texttt{(n, y)} & indexed with 8-bit offset \\
\texttt{(nn, z)} & indexed with 16-bit offset \\
\texttt{(x)}, \texttt{(y)}, \texttt{(z)} & indirect
\end{tabular}



\begin{tabular}{l l l}
\texttt{op8\_2} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{\#i}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{op8\_2ni} & Any of \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\texttt{altacc8} & Any of \texttt{xl}, \texttt{xh}, \texttt{yl}, \texttt{yh}, \texttt{zl}, \texttt{zh}. \\
\texttt{op16\_2} & Any of \texttt{x}, \texttt{\#ii}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{op16\_2} & Any of \texttt{x}, \texttt{mm}, \texttt{(n, sp)}. \\
\texttt{altacc16} & Any of \texttt{x}, \texttt{z}. \\
\texttt{op8\_1} & Any of \texttt{xl}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(n, y)}. \\
\texttt{op16\_1} & Any of \texttt{y}, \texttt{mm}, \texttt{(n, sp)}, \texttt{(nn, z)}. \\
\end{tabular}

\chapter{Instructions}

\section{8-bit two-operand instructions}

Instructions where the location is used for \texttt{altacc8} and \texttt{op8} are not valid.

\subsection{adc: 8-bit addition with carry}

\begin{tabular}{l l l}
Assembler code            & Operation                                  & f8l \\
\texttt{adc xl, op8\_2}      & \texttt{xl = xl + op8\_2 + c}           & Yes \\
\texttt{adc altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2 + c} & Yes \\
\texttt{adc op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni + xl + c}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{add: 8-bit addition}

\begin{tabular}{l l l}
Assembler code            & Operation                              & f8l \\
\texttt{add xl, op8\_2}      & \texttt{xl = xl + op8\_2}           & Yes \\
\texttt{add altacc8, op8\_2} & \texttt{altacc8 = altacc8 + op8\_2} & Yes \\
\texttt{add op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + xl} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{and: 8-bit bitwise and}

\begin{tabular}{l l l}
Assembler code               & Operation                            & f8l \\
\texttt{and xl, op8\_2}      & \texttt{xl = xl \& op8\_2}           & Yes \\
\texttt{and altacc8, op8\_2} & \texttt{altacc8 = altacc8 \& op8\_2} & Yes \\
\texttt{and op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \& xl}   & Yes
\end{tabular}


\subsection{cp: 8-bit comparison}

Subtraction where the result is used to update the flags only.

\begin{tabular}{l l l}
Assembler code              & Operation                      & f8l\\
\texttt{cp xl, op8\_2}      & \texttt{xl + \~{}op8\_2 + 1}      & Yes \\
\texttt{cp altacc8, op8\_2} & \texttt{altacc8 + \~{}op8\_2 + 1} & Yes \\
\texttt{cp op8\_2, xl}      & \texttt{op8\_2 + \~{}xl + 1}      & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{or: 8-bit bitwise or}

\begin{tabular}{l l l}
Assembler code              & Operation                           & f8l \\
\texttt{or xl, op8\_2}      & \texttt{xl = xl | op8\_2}           & Yes \\
\texttt{or altacc8, op8\_2} & \texttt{altacc8 = altacc8 | op8\_2} & Yes \\
\texttt{or op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni | xl}   & Yes
\end{tabular}


\subsection{sbc: 8-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code                 & Operation                                  & f8l \\
\texttt{sbc xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + c}           & Yes \\
\texttt{sbc altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + c} & Yes \\
\texttt{sbc op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + c}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{sub: 8-bit subtraction}

\begin{tabular}{l l l}
Assembler code                 & Operation                                  & f8l \\
\texttt{sub xl, op8\_2ni}      & \texttt{xl = xl + \~{}op8\_2ni + 1}           & Yes \\
\texttt{sub altacc8, op8\_2ni} & \texttt{altacc8 = altacc8 + \~{}op8\_2ni + 1} & Yes \\
\texttt{sub op8\_2ni, xl}      & \texttt{op8\_2ni = op8\_2ni + \~{}xl + 1}     & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{xor: 8-bit bitwise exclusive or}

\begin{tabular}{l l l}
Assembler code               & Operation                              & f8l \\
\texttt{xor xl, op8\_2}      & \texttt{xl = xl \^{} op8\_2}           & Yes \\
\texttt{xor altacc8, op8\_2} & \texttt{altacc8 = altacc8 \^{} op8\_2} & Yes \\
\texttt{xor op8\_2ni, xl}    & \texttt{op8\_2ni = op8\_2ni \^{} xl}   & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nz}


\section{16-bit 2-operand-instructions}

Todo: Document possible altacc prefixes.

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                              & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2 + c}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{addw: 16 bit addition}

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{adcw xl, op16\_2}   & \texttt{y = y + op16\_2}           & No \\
\texttt{adcw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni + y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{orw: 16 bit bitwise or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code             & Operation                          & f8l \\
\texttt{orw xl, op16\_2}   & \texttt{y = y | op16\_2}           & No \\
\texttt{orw op16\_2ni, xl} & \texttt{op16\_2ni = op16\_2ni | y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\subsection{sbcw: 16 bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{sbcw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + c}       & No \\
\texttt{sbcw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{subw: 16 bit subtraction}

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{subw xl, op16\_2ni} & \texttt{y = y + \~{}op16\_2ni + 1}       & No \\
\texttt{subw op16\_2ni, xl} & \texttt{op16\_2 = \~{}op16\_2ni + y + 1} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{xorw: 16 bit bitwise exclusive or}

todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

\begin{tabular}{l l l}
Assembler code              & Operation                             & f8l \\
\texttt{xorw xl, op16\_2}   & \texttt{y = y \^{} op16\_2}           & No \\
\texttt{xorw op16\_2ni, xl} & \texttt{op16\_ni2 = op16\_2ni \^{} y} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{nzo}


\section{8-bit 1-operand-instructions}

\subsection{clr: 8-bit clear}

\begin{tabular}{l l l}
Assembler code       & Operation               & f8l \\
\texttt{clr op8\_1}  & \texttt{op8 = 0x00}     & Yes, except (n, y) \\
\texttt{clr altacc8} & \texttt{altacc8 = 0x00} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{dec: 8-bit decrement}

\begin{tabular}{l l l}
Assembler code       & Operation                       & f8l \\
\texttt{dec op8\_1}  & \texttt{op8 = op8 + -1}         & Yes, except (n, y) \\
\texttt{dec altacc8} & \texttt{altacc8 = altacc8 + -1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{inc: 8-bit increment}

\begin{tabular}{l l l}
Assembler code       & Operation                      & f8l \\
\texttt{inc op8\_1}  & \texttt{op8 = op8 + 1}         & Yes, except (n, y) \\
\texttt{inc altacc8} & \texttt{altacc8 = altacc8 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{hcnzo}


\subsection{push: 8-bit push onto stack}

\begin{tabular}{l l l}
Assembler code        & Operation                 & f8l \\
\texttt{push op8\_1}  & \texttt{(--sp) = op8}     & Yes, except (n, y) \\
\texttt{push altacc8} & \texttt{(--sp) = altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{sll: 8-bit shift left logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                   & f8l \\
\texttt{sll op8\_1}  & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{op8 = op8 << 1}}         & Yes, except (n, y) \\
\texttt{sll altacc8} & \makecell{\texttt{c = (op8 \& 0x80) >> 7}\\\texttt{altacc8 = altacc8 << 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cz}


\subsection{srl: 8-bit shift right logical}

\begin{tabular}{l l l}
Assembler code       & Operation                                                            & f8l \\
\texttt{srl op8\_1}  & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{op8 = op8 >> 1}}         & Yes (except (n, y) \\
\texttt{srl altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = altacc8 >> 1}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cz}


\subsection{rlc: 8-bit rotate left through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rlc op8\_1}  & \makecell{\texttt{tc = (op8  \& 0x80) >> 7}\\\texttt{op8 = (op8 << 1) | c}\\\texttt{c = tc}}            & Yes (except (n, y) \\
\texttt{rlc altacc8} & \makecell{\texttt{tc = (altacc8 \& 0x80) >> 7}\\\texttt{altacc8 = (altacc8 << 1) | c}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cz}


\subsection{rrc: 8-bit rotate right through carry}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                                               & f8l \\
\texttt{rrc op8\_1}  & \makecell{\texttt{tc = op8  \& 0x01}\\\texttt{op8 = (op8 >> 1) | (c << 7)}\\\texttt{c = tc}}            & Yes (except (n, y) \\
\texttt{rrc altacc8} & \makecell{\texttt{tc = altacc8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | (c << 7)}\\\texttt{c = tc}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cz}


\subsection{tst: 8-bit test}

Set n and z flags according to value of operand, o flag by parity, reset c.

\begin{tabular}{l l l}
Assembler code       & Operation        & f8l \\
\texttt{tst op8\_1}  & \texttt{op8}     & Yes (except (n, y) \\
\texttt{tst altacc8} & \texttt{altacc8} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\section{16-bit 1-operand-instructions}

\subsection{adcw: 16 bit addition with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{adcw op16\_1}  & \texttt{op16 = op16 + c}         & No \\
\texttt{adcw altacc16} & \texttt{altacc16 = altacc16 + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{clrw: 16-bit clear}

\begin{tabular}{l l l}
Assembler code         & Operation                  & f8l \\
\texttt{clrw op16\_1}  & \texttt{op16 = 0x0000}     & Yes \\
\texttt{clrw altacc15} & \texttt{altacc16 = 0x0000} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{incw: 16-bit increment}

\begin{tabular}{l l l}
Assembler code         & Operation                        & f8l \\
\texttt{incw op16\_1}  & \texttt{op16 = op16 + 1}         & Yes \\
\texttt{incw altacc16} & \texttt{altacc16 = altacc16 + 1} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code          & Operation                         & f8l \\
\texttt{pushw op16\_1}  & \texttt{sp -= 2; (sp) = op16}     & Yes \\
\texttt{pushw altacc16} & \texttt{sp -= 2; (sp) = altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{sbcw: 16-bit subtraction with carry}

\begin{tabular}{l l l}
Assembler code         & Operation                                 & f8l \\
\texttt{sbcw op16\_1}  & \texttt{op16 = op16 + 0xffff + c}         & No \\
\texttt{sbcw altacc16} & \texttt{altacc16 = altacc16 + 0xffff + c} & No
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{tstw: 16-bit test}

Set n and z flags according to value of operand, o flag by parity, set c.

\begin{tabular}{l l l}
Assembler code         & Operation         & f8l \\
\texttt{tstw op16\_1}  & \texttt{op16}     & Yes \\
\texttt{tstw altacc16} & \texttt{altacc16} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\section{8-bit loads}

\subsection{ld}

ld xl, \#i (12)

ld xl, mm [zn] (12)

ld xl, (n, sp) [zn] (12)

ld xl, (nn, z) [zn] (12)

ld xl, (y) [zn] (12)

ld xl, (n, y) [zn] (12)

ld xl, xh (02)

ld xl, yl (012)

ld xl, yh (012)

ld xl, zl (012)

ld xl, zh (012)

ld mm, xl (12)

ld (n, sp), xl (12)

ld (nn, z), xl (12)

ld (y), xl (12)

ld (n, y), xl (12)


\subsection{ldi}

ldi (z), (y) (2)   ; (z++) = (y)

\subsubsection*{Affected Flags}

\texttt{nz}


\section{16-bit loads}

\subsection{ldw}

ldw y, \#ii (2)

ldw y, mm [ZN] (2)

ldw y, (n, sp) [ZN] (2)

ldw y, (nn, z) [ZN] (2)

ldw y, (n, y) [ZN] (2)

ldw y, (y) [ZN] (2) 

ldw y, x (2)

ldw y, \#d (2)

ldw mm, y (2)

ldw (n, sp), y (2)

ldw (nn, z), y (2)

ldw x, y

ldw z, y (0)

ldw (y), x (2)

ldw (n, y), x

ldw y, sp (2)

ldw ((d, sp)), y (2)


\subsection{ldwi}

ldwi (z), (y) (2) ; (z++) = (y); (z++) = (y)

\subsubsection*{Affected Flags}

\texttt{nz}


\section{Other 8-bit instructions}

\subsection{bool: 8-bit cast to bool}

bool xl (12) ; cast to bool

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{cax: 8-bit compare and exchange}

z is set according to the old value of (y) - zl.

\begin{tabular}{l l l}
Assembler code            & Operation                                        & f8l \\
\texttt{cax (y), zl, xl}  & \texttt{if ((y) == zl) (y) = xl; else zl = (y);} & Yes \\
\texttt{cax (y), zl, xh}  & \texttt{if ((y) == zl) (y) = xh; else zl = (y);} & Yes \\
\texttt{cax (y), zl, zh}  & \texttt{if ((y) == zl) (y) = zh; else zl = (y);} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{da: decimal adjust}

da xl [ocznh] (12)        ; decimal adjust for addition / subtraction - binary coded decimal semantics


\subsection{mad: multiply and add}

mad x, mm, yl [zn]        ; x <- m * yl + xh + c

mad x, (n, sp), yl [zn]   ; x <- (n, sp) * yl + xh + c

mad x, (nn, z), yl [zn]   ; x <- (nn, z) * yl + xh + c

mad x, (z), yl [zn]       ; x <- (z) * yl + xh + c


\subsection{msk: mask}

msk (y), xl, \#i [z](12)   ; (y) = xl \& i | (y) \& ~i; z flag according to (y) \& ~i


\subsection{pop: 8-bit pop from stack}

\begin{tabular}{l l l}
Assembler code       & Operation                 & f8l \\
\texttt{pop xl}      & \texttt{xl = (sp++)}      & Yes \\
\texttt{pop altacc8} & \texttt{altacc8 = (sp++)} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{push: 8-bit push onto stack}

Ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code    & Operation             & f8l \\
\texttt{push \#i} & \texttt{(--sp) = \#i} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{rot: 8-bit rotate}

\begin{tabular}{l l l}
Assembler code            & Operation                                                    & f8l \\
\texttt{rot xl, \#i}      & \texttt{xl = (xl << \#i) | (xl >> (8 - \#i))}                & No \\
\texttt{rot altacc8, \#i} & \texttt{altacc8 = (altacc8 << \#i) | (altacc8 >> (8 - \#i))} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none todo: do we want some flags to be affedted?


\subsection{sra: 8-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code       & Operation                                                                               & f8l \\
\texttt{sra xl}      & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{xl = (xl >> 1) | xl \& 0x80}}               & Yes \\
\texttt{sra altacc8} & \makecell{\texttt{c = op8 \& 0x01}\\\texttt{altacc8 = (altacc8 >> 1) | altacc \& 0x80}} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cz}


\subsection{thrd}

thrd xl (12) ; get current hardware thread number

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{xch: 8-bit exchange}

xch xl, (n, sp) (12)

xch xl, (y) (12)

xch yl, yh (2)            ; exchange yl with yh.

xch f, (n, sp) [xxxocznh]

\section{Other 16-bit instructions}

\subsection{addw: 16-bit addition}

\texttt{addw sp, \#d} ignores all flags, changes no flags, not even the reserved ones.

\begin{tabular}{l l l}
Assembler code              & Operation                          & f8l \\
\texttt{addw sp, \#d}       & \texttt{sp = sp + \#d}             & Yes \\
\texttt{addw y, \#d}        & \texttt{y = y + \#d}               & Yes \\
\texttt{addw altacc16, \#d} & \texttt{altacc16 = altacc16 + \#d} & Yes
\end{tabular}

\subsubsection*{Affected Flags}

none (\texttt{addw sp, \#d}) or \texttt{cnzo} (all others).


\subsection{boolw: 16-bit cast to bool}

boolw y (2)

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{caxw: 16-bit compare and exchange}

z is set according to the old value of (y) - z.

\begin{tabular}{l l l}
Assembler code           & Operation                                     & f8l \\
\texttt{caxw (y), z, x}  & \texttt{if ((y) == z) (y) = x; else z = (y);} & Yes \\

\end{tabular}

\subsubsection*{Affected Flags}

\texttt{z}


\subsection{cpw: 16-bit comparison}

cpw y, \#ii (02)

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{decw: 16-bit decrement}

\begin{tabular}{l l l}
Assembler code        & Operation                       & f8l \\
\texttt{decw (n, sp)} & \texttt{(n, sp) = (n, sp) + -1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{incnw: 16-bit increment without carry update}

Ignores all flags, changes no flags (except possibly the reserved ones).

\begin{tabular}{l l l}
Assembler code          & Operation                        & f8l \\
\texttt{incnw y}        & \texttt{y = y + 1}               & No \\
\texttt{incnw altacc16} & \texttt{altacc16 = altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{negw: 16-bit negation}

\begin{tabular}{l l l}
Assembler code         & Operation                            & f8l \\
\texttt{negw y}        & \texttt{y = \~{}y + 1}               & No \\
\texttt{negw altacc16} & \texttt{altacc16 = \~{}altacc16 + 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnzo}


\subsection{mul: multiplication}

mul y [ZNC] (2)        ; y = yl * yh , clears carry.


\subsection{popw: 16-bit pop from stack}

\begin{tabular}{l l l}
Assembler code         & Operation                         & f8l \\
\texttt{popw y}        & \texttt{y = (sp); sp += 2}        & Yes \\
\texttt{popw altacc16} & \texttt{altacc16 = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{pushw: 16-bit push onto stack}

\begin{tabular}{l l l}
Assembler code          & Operation                    & f8l \\
\texttt{pushw \#ii}  & \texttt{sp -= 2; (sp) = \#ii} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none

\subsection{rlcw: 16-bit rotate left through carry}

rlcw y [ZNC] (2)

rlcw (n, sp) [ZNC]


\subsection{rrcw: 16-bit rotate right through carry}

rrcw y [ZNC] (2)

rrcw (n, sp) [ZNC]

\subsection{sex: sign-extend}

sex y, xl (12) [ZN]    ; sign-extend xl to y

\subsection{sllw: 16-bit shift left logical}

\begin{tabular}{l l l}
Assembler code                  & Operation                                    & f8l \\
\texttt{sllw y}                 & \texttt{c = y \& (0x8000 >> 15); y = y << 1} & No \\
\texttt{sllw altacc16}          & \texttt{altacc16 = altacc16 << 1}            & No \\
\texttt{sllw y, xl}             & \texttt{c = y \& (0x8000 >> 15);y = y << xl} & No \\
\texttt{sllw altacc16, altacc8} & \texttt{altacc16 = altacc16 << altacc8}      & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz} (\texttt{sllw y} and \texttt{sllw altacc16}) or \texttt{nz} (others).


\subsection{sraw: 16-bit shift right arithmetic}

\begin{tabular}{l l l}
Assembler code         & Operation                                                               & f8l \\
\texttt{sraw y}        & \texttt{c = y \& 0x0001; y = y >> 1 | y \& 0x8000}                      & No \\
\texttt{sraw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1 | altacc16 \& 0x8000} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}

\subsection{srlw: 16-bit shift right logical}

\begin{tabular}{l l l}
Assembler code         & Operation                                          & f8l \\
\texttt{srlw y}        & \texttt{c = y \& 0x0001; y = y >> 1}               & No \\
\texttt{srlw altacc16} & \texttt{c = y \& 0x0001; altacc16 = altacc16 >> 1} & No \\
\end{tabular}

\subsubsection*{Affected Flags}

\texttt{cnz}


\subsection{xchw: 16-bit exchange}

xchw x, (y) (2)

xchw y, (n, sp) [] (2)


\subsection{zex: zero-extend}

zex y, xl (12) ; zero-extend xl to y

\subsubsection*{Affected Flags}

\texttt{z}


\section{Bit Instructions}

\subsection{xchb: exchange bit}

xchb xl, mm, \#b (12) ; exchange xl with bit b at mm. z flag according to new value of xl.

\subsubsection*{Affected Flags}

\texttt{z}


\section{Relative Jumps}

\subsection{dnjnz}

dnjnz yh, \#d (2) ; decrement yh, without updating carry, jump if result is not zero.

\subsubsection*{Affected Flags}

\texttt{nz}


\subsection{jr}

jr \#d                 ; jump relative to pc. Ignores all flags, changes no flags, not even reserved ones.


\subsection{jrc}

jrc \#d                ; if c


\subsection{jrle}

jrle \#d               ; if !c or z


\subsection{jrn}

jrn \#d                ; if n


\subsection{jrnc}

jrnc \#d               ; if !c


\subsection{jrnn}

jrnn \#d               ; if !n


\subsection{jrno}

jrno \#d               ; if !o


\subsection{jrnz}

jrnz \#d               ; if !z


\subsection{jrsge}

jrsge \#d              ; if n xnor o


\subsection{jrsle}

jrsle \#d              ; if (z or (n xor o))


\subsection{jrslt}

jrslt \#d              ; if n xor o



\subsection{jrz}

jrz \#d                ; jump relative to pc if z flag is set.


\section{Other Instructions}

\subsection{call}

\begin{tabular}{l l l}
Assembler code         & Operation                                  & f8l \\
\texttt{call \#ii}     & \texttt{sp -= 2; (sp) = pc; pc = \#ii}     & Yes \\
\texttt{call y}        & \texttt{sp -= 2; (sp) = pc; pc = y}        & Yes \\
\texttt{call altacc16} & \texttt{sp -= 2; (sp) = pc; pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{jp: jump}

\texttt{jp \#ii} ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code       & Operation              & f8l \\
\texttt{jp \#ii}     & \texttt{pc = \#ii}     & Yes \\
\texttt{jp y}        & \texttt{pc = y}        & Yes \\
\texttt{jp altacc16} & \texttt{pc = altacc16} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{ret: return}

\begin{tabular}{l l l}
Assembler code & Operation                   & f8l \\
\texttt{ret}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{reti: return from interrupt}

Ignores all flags, changes no flags, not even reserved ones.

\begin{tabular}{l l l}
Assembler code  & Operation                   & f8l \\
\texttt{reti}   & \texttt{pc = (sp); sp += 2} & Yes \\
\end{tabular}

\subsubsection*{Affected Flags}

none


\subsection{trap}

Opcode 0x00. Trap reset.

\begin{tabular}{l l l}
Assembler code  & Operation  & f8l \\
\texttt{trap}   & Trap reset & Yes \\
\end{tabular}


\chapter{Opcode Map}

todo - see opcodemap.ods for now.

\chapter{Peripherals}

\section{Watchdog and Reset}

The watchdog has an 8-bit configuration register and a 16-bit counter register.

When the watchdog is active, the system clock is divided by 16, and then used to increment the counter register.

The system is reset when a power-on reset happens, the watchdog counter register reaches 0xffff, the trap instruction is executed, or the byte at memory address 0 is written.

\subsection*{Configuration Register}

\vspace{3mm}
\begin{bytefield}[bitwidth=0.13\linewidth]{8}
	\bitheader{0,1,2,3,4,7} \\
	\bitbox{1}{dog active} & \bitbox{1}{dog reset} & \bitbox{1}{trap reset} & \bitbox{1}{null reset} & \bitbox{4}{reserved}
\end{bytefield}

The lowest bit of the configuration register decides if the watchdog is active. It is 0 on reset. The following three bits give the reason of the previous reset. On a power-on-reset they are all 0.

\section{Interrupt Controller}

The interrupt controller has a 16-bit enable register, and a 16-bit active register.

\vspace{3mm}
\begin{bytefield}[bitwidth=0.06\linewidth]{8}
	\bitheader{0,1,15} \\
	\bitbox{1}{tm 0} & \bitbox{15}{reserved}
\end{bytefield}

When an interrupt happens and the corresponding bit in the enable register is set, the corresponding bit in the active register is set. When a bit in the active register is set, and no interrupt routine is currently executing, the program counter is put onto the stack and then set to 0x4004. From then on, an interrupt routine is considered to be executing until the \texttt{reti} instruction is executed.

The lowest bit of the enable register indicates that interrupts from timer 0 are enabled. The lowest bit of the active register indicates that an interrupt from timer 0 is active. These bits are 0 on reset. All other bits are reserved.

\section{Timer}

todo

\section{GPIO}

todo

\end{document}

