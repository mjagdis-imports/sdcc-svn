A quick summary on the f8. To be turned into a proper manual at some later time.


Introduction:

Little-endian. Stack grows downward. 16-bit flat address space. PC after reset: 0x4000. Other registers (including sp) after reset: unspecified. (P)ROM/Flash from 0x4000. RAM up to 0x3fff. I/O from 0x0000. Empty PROM/Flash is logically 0x00 (to trigger trap). All instructions execute atomically.
Safety features: trap on opcode 0x00. Trap on write to address 0x0000.

Registers:

16-bit:
pc
sp
x  - lower half xl is default 8-bit-accumulator.
y  - default 16-bit accumulator.
z

8-bit:
f  - upper 3 bits for internal use, lower 5 for user: o (overflow), z (zero), n (negative), c (carry), h (half-carry)
xl - default 8-bit accu
xh
yl
yh
zl
zh


Instructions:

Instructions have up to 3 source and 2 destination operands. At most one source and one destination operand are in memory.

Instruction format: [optional prefix byte] [opcode byte] [0 to 2 operand bytes]

Prefixes (numbers in parenthesis are uses to indictae which prefix bytes are valid on which instructions):
swapped operands (0)
altacc1 - use alternative accumulator - xh instead of xl for 8-bit (1)
altacc2 - use alternative accumulator - yl instead of xl for 8-bit, z instead of y for 16-bit (2)
altacc3 - use alternative accumulator - zl instead of xl for 8-bit, x instead of y for 16-bit (2)
altacc4 - use alternative accumulator - yh instead of xl for 8-bit, z instead of y for 16-bit (2)
altacc5 - use alternative accumulator - zh instead of xl for 8-bit (1)

Addressing modes:

xl, xh, yl, yh, zl, zh - 8-bit register
x, y, z                - 16 bit register
#i                     - 8-bit immediate
#ii                    - 16-bit immediate
mm                     - 8 or 16-bit direct
(n, sp), (n, y)        - indexed with 8-bit offset
(nn, z)                - indexed with 16-bit offset              

8-bit 2-operand-instructions:

sub xl, op [oznch] (012) ; xl = xl + ~op + 1 (except for #i op)
sbc xl, op [oznch] (012) ; xl = xl + ~op + c (except for #i op)
add xl, op [oznch] (012) ; xl = xl + op
adc op, xl [oznch] (012) ; xl = xl + op + c
cp  xl, op [oznch] (012) ; xl + ~op + 1
or  xl, op [zn] (012)    ; xl = xl | op
and xl, op [zn] (012)    ; xl = xl & op
xor xl, op [zn] (012)    ; xl = xl ^ op

Valid op:
zl
xh
yl
yh
#i      ; immediate
mm      ; direct
(n, sp) ; indexed
(nn, z) ; indexed

Instruction documentation:
mnemonic operands [affected flags] (valid prefixes) ; description

16-bit 2-operand-inst

subw y, op [oznc] (02) ; y = y + ~op + 1 (except for immd op - saves 1 opcode)
sbcw y, op [oznc] (02) ; y = y + ~op + c (except for immd op - saves 1 opcode)
addw y, op [oznc] (02) ; y = y + op
adcw y, op [oznc] (02) ; y = y + op + c
orw y, op [ozn] (02)   ; todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?
xorw y, op [ozn] (02)  ; todo: do we really want the effect on o here? If yes, why not on the 8-bit logic ops?

Valid op:
x
#ii     ; immediate
mm      ; direct
(n, sp) ; indexed

8-bit 1-operand-instructions:

srl op [cz] (12)    ; op = op >> 1
sll op [cz] (12)    ; op = op << 1
rrc op [cz] (12)    ; op = (op >> 1) | (op << 7)
rlc op [cz] (12)    ; op = (op << 1) | (op >> 7)
inc op [oznch] (12) ; op = op + 1
dec op [oznch] (12) ; op = op + -1
clr op [] (12)      ; op = 0x00
tst op [oczn] (12)  ; set n and z flags according to value of op, o flag by parity, resets c.
push op [] (12)

Valid op:
xl
mm      ; direct
(n, sp) ; indexed
(n, y)  ; indexed

16-bit 1-operand-instructions:

clrw op (2)        ; op = 0
incw op [oczn] (2) ; op = op + 1
adcw op [oczn] (2) ; op = op + c
sbcw op [oczn] (2) ; op = op + 0xffff + c
pushw op [] (2)
tstw [oczn] (2)    ; set n and z flags according to value of op, o flag by parity, sets c.

Valid op:
y
mm      ; direct
(n, sp) ; indexed
(nn, z) ; indexed

8-bit-loads:

ld xl, #i (12)
ld xl, mm [zn] (12)
ld xl, (n, sp) [zn] (12)
ld xl, (nn, z) [zn] (12)
ld xl, (y) [zn] (12)
ld xl, (n, y) [zn] (12)
ld xl, xh (02)
ld xl, yl (012)
ld xl, yh (012)
ld xl, zl (012)
ld xl, zh (012)
ld mm, xl (12)
ld (n, sp), xl (12)
ld (nn, z), xl (12)
ld (y), xl (12)
ld (n, y), xl (12)
ldi (z), (y) [zn] (2)   ; (z++) = (y)

16-bit loads:

ldw y, #ii (2)
ldw y, mm [ZN] (2)
ldw y, (n, sp) [ZN] (2)
ldw y, (nn, z) [ZN] (2)
ldw y, (n, y) [ZN] (2)
ldw y, (y) [ZN] (2) 
ldw y, x (2)
ldw y, #d (2)
ldw mm, y (2)
ldw (n, sp), y (2)
ldw (nn, z), y (2)
ldw x, y
ldw z, y (0)
ldw (y), x (2)
ldw (n, y), x
ldw y, sp (2)
ldw ((d, sp)), y (2)
ldwi (z), (y) [zn] (2)    ; (z++) = (y); (z++) = (y)

Other 8-bit instructions:

bool xl [z] (12)          ; cast to bool
sra xl [cz] (12)
da xl [ocznh] (12)        ; decimal adjust for addition / subtraction - binary coded decimal semantics
pop xl (12)               ; xl = (sp++)
xch xl, (n, sp) (12)
xch xl, (y) (12)
xch yl, yh (2)            ; exchange yl with yh.
msk (y), xl, #i [z](12)   ; (y) = xl & i | (y) & ~i; z flag according to (y) & ~i
cax (y), zl, xl [z] (1)   ; if ((y) == zl) (y) = xl; else zl = (y); compare-and-exchange
mad x, mm, yl [zn]        ; x <- m * yl + xh + c
mad x, (n, sp), yl [zn]   ; x <- (n, sp) * yl + xh + c
mad x, (nn, z), yl [zn]   ; x <- (nn, z) * yl + xh + c
mad x, (z), yl [zn]       ; x <- (z) * yl + xh + c
rot xl, #i (12)           ; rotate xl left by i
thrd xl (12) [z]          ; get current hardware thread number
push #i []                ; Ignores all flags, changes no flags, not even the upper ones.
xch f, (n, sp) [xxxocznh]

Other 16-bit instructions:

negw y [OCZN] (2)      ; y = ~y + 1
boolw y [Z] (2)
srlw y [ZNC] (2)
sllw y [ZNC] (2)
rrcw y [ZNC] (2)
rlcw y [ZNC] (2)
sraw y [ZNC] (2)
mul y [ZNC] (2)        ; y = yl * yh , clears carry.
popw y (2)
xchw x, (y) (2)
xchw y, (n, sp) [] (2)
caxw (y), z, x [Z]     ; if ((y) == z) (y) = x; else z = (y); compare-and-exchange.
addw sp, #d            ; Ignores all flags, changes no flags, not even the upper ones.
addw y, #d [OCZN] (2)
cpw y, #ii [OCZN] (02)
incnw y (2)            ; Ignores all flags, changes no flags (except possibly the upper ones).
decw (n, sp) [OCZN]
pushw #ii []
sllw y, xl [ZN] (12)
rlcw (n, sp) [ZNC]
rrcw (n, sp) [ZNC]
sex y, xl (12) [ZN]    ; sign-extend xl to y
zex y, xl (12) [Z]     ; zero-extend xl to y

Bit instructions:

xchb xl, mm, #b [Z] (12) ; exchange xl with bit b at mm. z flag according to new value of xl.

Relative jumps:

jr #d                 ; jump relative to pc. Ignores all flags, changes no flags, not even the upper ones.
dnjnz yh, #d [ZN] (2) ; decrement yh, without updating carry, jump if result is not zero.
jrz #d                ; jump relative to pc if z flag is set.
jrnz #d               ; if !z
jrc #d                ; if c
jrnc #d               ; if !c
jrn #d                ; if n
jrnn #d               ; if !n
jrno #d               ; if !o
jrsge #d              ; if n xnor o
jrslt #d              ; if n xor o
jrsle #d              ; if (z or (n xor o))
jrle #d               ; if !c or z

Other instructions:

call #ii
call y (2)
jp #ii     ; Ignores all flags, changes no flags, not even the upper ones.
jp y (2)
ret
reti       ; Ignores all flags, changes no flags, not even the upper ones.
trap       ; Opcode 0x00. Trap reset.

