/*
   serpent.c.in
   op: encrypt, decrypt

   The serpent cipher was an AES competition finalist, that ultimately lost to Rijndael.

   The test is a C23/C2y implementation derived from the CycloneCrypto one.
*/

#include <testfwk.h>

#define OP_{op}

// This implementation needs quite some code memory and some data memory.
#if defined(__SDCC_pdk13) || defined(__SDCC_pdk14) || defined(__SDCC_pdk15) \
  || defined(__SDCC_mcs51) \
  || defined(__SDCC_mos6502) || defined(__SDCC_mos65c02) \
  || defined(__SDCC_sm83)
#define LACK_OF_MEMORY
#endif

#if defined(__SDCC) && __STDC_VERSION__ <= 202311L
#define __STDC_VERSION__ 202512L
#endif

#include <string.h>
#include <stdint.h>
#include <stdbit.h>

#if __STDC_VERSION__ <= 202311L
//Load unaligned 32-bit integer (little-endian encoding)
 #define LOAD32LE(p) ( \
    ((uint32_t)(((uint8_t *)(p))[0]) << 0) | \
    ((uint32_t)(((uint8_t *)(p))[1]) << 8) | \
    ((uint32_t)(((uint8_t *)(p))[2]) << 16) | \
    ((uint32_t)(((uint8_t *)(p))[3]) << 24))
//Store unaligned 32-bit integer (little-endian encoding)
 #define STORE32LE(a, p) \
    ((uint8_t *)(p))[0] = ((uint32_t)(a) >> 0) & 0xFFU, \
    ((uint8_t *)(p))[1] = ((uint32_t)(a) >> 8) & 0xFFU, \
    ((uint8_t *)(p))[2] = ((uint32_t)(a) >> 16) & 0xFFU, \
    ((uint8_t *)(p))[3] = ((uint32_t)(a) >> 24) & 0xFFU
#define ROL32(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#define ROR32(x, n) (((x) >> (n)) | ((x) << (32-(n))))
#else
#define LOAD32LE(i) stdc_load8_leu32(i)
#define STORE32LE(v, o) stdc_store8_leu32(v, o)
#define ROL32(x, n) stdc_rotate_left(x, n)
#define ROR32(x, n) stdc_rotate_right(x, n)
#endif

typedef uint_fast8_t uint_t;

#ifndef LACK_OF_MEMORY
/**
 * Copyright (C) 2010-2025 Oryx Embedded SARL. All rights reserved.
 *
 * This file is part of CycloneCRYPTO Open.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * Serpent is a block cipher algorithm which supports a key size of 128, 192
 * or 256 bits. S-box functions are implemented as per Dag Arne Osvik's
 * paper "Speeding up Serpent"
 **/
 
typedef struct
{
   uint32_t k[33][4];
} SerpentContext;

//Serpent related functions
void serpentInit(SerpentContext *context, const uint8_t *key, size_t keyLen);

void serpentEncryptBlock(SerpentContext *context, const uint8_t *input,
   uint8_t *output);

void serpentDecryptBlock(SerpentContext *context, const uint8_t *input,
   uint8_t *output);

//Golden ration
#define PHI 0x9E3779B9

//S-box 0
#define SBOX0(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r3 ^= r0; r4 = r1; \
   r1 &= r3; r4 ^= r2; \
   r1 ^= r0; r0 |= r3; \
   r0 ^= r4; r4 ^= r3; \
   r3 ^= r2; r2 |= r1; \
   r2 ^= r4; r4 = ~r4; \
   r4 |= r1; r1 ^= r3; \
   r1 ^= r4; r3 |= r0; \
   r1 ^= r3; r4 ^= r3; \
   r3 = r0; r0 = r1; r1 = r4; \
}

//Inverse S-box 0
#define SBOX0_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r2 = ~r2; r4 = r1; \
   r1 |= r0; r4 = ~r4; \
   r1 ^= r2; r2 |= r4; \
   r1 ^= r3; r0 ^= r4; \
   r2 ^= r0; r0 &= r3; \
   r4 ^= r0; r0 |= r1; \
   r0 ^= r2; r3 ^= r4; \
   r2 ^= r1; r3 ^= r0; \
   r3 ^= r1; \
   r2 &= r3; \
   r4 ^= r2; \
   r2 = r1; r1 = r4; \
}

//S-box 1
#define SBOX1(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r0 = ~r0; r2 = ~r2; \
   r4 = r0; r0 &= r1; \
   r2 ^= r0; r0 |= r3; \
   r3 ^= r2; r1 ^= r0; \
   r0 ^= r4; r4 |= r1; \
   r1 ^= r3; r2 |= r0; \
   r2 &= r4; r0 ^= r1; \
   r1 &= r2; \
   r1 ^= r0; r0 &= r2; \
   r0 ^= r4; \
   r4 = r0; r0 = r2; r2 = r3; r3 = r1; r1 = r4; \
}

//Inverse S-box 1
#define SBOX1_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r1; r1 ^= r3; \
   r3 &= r1; r4 ^= r2; \
   r3 ^= r0; r0 |= r1; \
   r2 ^= r3; r0 ^= r4; \
   r0 |= r2; r1 ^= r3; \
   r0 ^= r1; r1 |= r3; \
   r1 ^= r0; r4 = ~r4; \
   r4 ^= r1; r1 |= r0; \
   r1 ^= r0; \
   r1 |= r4; \
   r3 ^= r1; \
   r1 = r0; r0 = r4; r4 = r2; r2 = r3; r3 = r4; \
}

//S-box 2
#define SBOX2(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r0; r0 &= r2; \
   r0 ^= r3; r2 ^= r1; \
   r2 ^= r0; r3 |= r4; \
   r3 ^= r1; r4 ^= r2; \
   r1 = r3; r3 |= r4; \
   r3 ^= r0; r0 &= r1; \
   r4 ^= r0; r1 ^= r3; \
   r1 ^= r4; r4 = ~r4; \
   r0 = r2; r2 = r1; r1 = r3; r3 = r4; \
}

//Inverse S-box 2
#define SBOX2_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r2 ^= r3; r3 ^= r0; \
   r4 = r3; r3 &= r2; \
   r3 ^= r1; r1 |= r2; \
   r1 ^= r4; r4 &= r3; \
   r2 ^= r3; r4 &= r0; \
   r4 ^= r2; r2 &= r1; \
   r2 |= r0; r3 = ~r3; \
   r2 ^= r3; r0 ^= r3; \
   r0 &= r1; r3 ^= r4; \
   r3 ^= r0; \
   r0 = r1; r1 = r4; \
}

//S-box 3
#define SBOX3(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r0; r0 |= r3; \
   r3 ^= r1; r1 &= r4; \
   r4 ^= r2; r2 ^= r3; \
   r3 &= r0; r4 |= r1; \
   r3 ^= r4; r0 ^= r1; \
   r4 &= r0; r1 ^= r3; \
   r4 ^= r2; r1 |= r0; \
   r1 ^= r2; r0 ^= r3; \
   r2 = r1; r1 |= r3; \
   r1 ^= r0; \
   r0 = r1; r1 = r2; r2 = r3; r3 = r4; \
}

//Inverse S-box 3
#define SBOX3_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r2; r2 ^= r1; \
   r0 ^= r2; r4 &= r2; \
   r4 ^= r0; r0 &= r1; \
   r1 ^= r3; r3 |= r4; \
   r2 ^= r3; r0 ^= r3; \
   r1 ^= r4; r3 &= r2; \
   r3 ^= r1; r1 ^= r0; \
   r1 |= r2; r0 ^= r3; \
   r1 ^= r4; \
   r0 ^= r1; \
   r4 = r0; r0 = r2; r2 = r3; r3 = r4; \
}

//S-box 4
#define SBOX4(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r1 ^= r3; r3 = ~r3; \
   r2 ^= r3; r3 ^= r0; \
   r4 = r1; r1 &= r3; \
   r1 ^= r2; r4 ^= r3; \
   r0 ^= r4; r2 &= r4; \
   r2 ^= r0; r0 &= r1; \
   r3 ^= r0; r4 |= r1; \
   r4 ^= r0; r0 |= r3; \
   r0 ^= r2; r2 &= r3; \
   r0 = ~r0; r4 ^= r2; \
   r2 = r0; r0 = r1; r1 = r4; \
}


//Inverse S-box 4
#define SBOX4_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r2; r2 &= r3; \
   r2 ^= r1; r1 |= r3; \
   r1 &= r0; r4 ^= r2; \
   r4 ^= r1; r1 &= r2; \
   r0 = ~r0; r3 ^= r4; \
   r1 ^= r3; r3 &= r0; \
   r3 ^= r2; r0 ^= r1; \
   r2 &= r0; r3 ^= r0; \
   r2 ^= r4; \
   r2 |= r3; r3 ^= r0; \
   r2 ^= r1; \
   r1 = r3; r3 = r4; \
}

//S-box 5
#define SBOX5(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r0 ^= r1; r1 ^= r3; \
   r3 = ~r3; r4 = r1; \
   r1 &= r0; r2 ^= r3; \
   r1 ^= r2; r2 |= r4; \
   r4 ^= r3; r3 &= r1; \
   r3 ^= r0; r4 ^= r1; \
   r4 ^= r2; r2 ^= r0; \
   r0 &= r3; r2 = ~r2; \
   r0 ^= r4; r4 |= r3; \
   r2 ^= r4; \
   r4 = r0; r0 = r1; r1 = r3; r3 = r2; r2 = r4; \
}

//Inverse S-box 5
#define SBOX5_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r1 = ~r1; r4 = r3; \
   r2 ^= r1; r3 |= r0; \
   r3 ^= r2; r2 |= r1; \
   r2 &= r0; r4 ^= r3; \
   r2 ^= r4; r4 |= r0; \
   r4 ^= r1; r1 &= r2; \
   r1 ^= r3; r4 ^= r2; \
   r3 &= r4; r4 ^= r1; \
   r3 ^= r4; r4 = ~r4; \
   r3 ^= r0; \
   r0 = r1; r1 = r4; r4 = r2; r2 = r3; r3 = r4; \
}

//S-box 6
#define SBOX6(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r2 = ~r2; r4 = r3; \
   r3 &= r0; r0 ^= r4; \
   r3 ^= r2; r2 |= r4; \
   r1 ^= r3; r2 ^= r0; \
   r0 |= r1; r2 ^= r1; \
   r4 ^= r0; r0 |= r3; \
   r0 ^= r2; r4 ^= r3; \
   r4 ^= r0; r3 = ~r3; \
   r2 &= r4; \
   r2 ^= r3; \
   r3 = r2; r2 = r4; \
}

//Inverse S-box 6
#define SBOX6_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r0 ^= r2; r4 = r2; \
   r2 &= r0; r4 ^= r3; \
   r2 = ~r2; r3 ^= r1; \
   r2 ^= r3; r4 |= r0; \
   r0 ^= r2; r3 ^= r4; \
   r4 ^= r1; r1 &= r3; \
   r1 ^= r0; r0 ^= r3; \
   r0 |= r2; r3 ^= r1; \
   r4 ^= r0; \
   r0 = r1; r1 = r2; r2 = r4; \
}

//S-box 7
#define SBOX7(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r1; r1 |= r2; \
   r1 ^= r3; r4 ^= r2; \
   r2 ^= r1; r3 |= r4; \
   r3 &= r0; r4 ^= r2; \
   r3 ^= r1; r1 |= r4; \
   r1 ^= r0; r0 |= r4; \
   r0 ^= r2; r1 ^= r4; \
   r2 ^= r1; r1 &= r0; \
   r1 ^= r4; r2 = ~r2; \
   r2 |= r0; \
   r4 ^= r2; \
   r2 = r1; r1 = r3; r3 = r0; r0 = r4; \
}

//Inverse S-box 7
#define SBOX7_INV(r0, r1, r2, r3) \
{ \
   uint32_t r4; \
   r4 = r2; r2 ^= r0; \
   r0 &= r3; r4 |= r3; \
   r2 = ~r2; r3 ^= r1; \
   r1 |= r0; r0 ^= r2; \
   r2 &= r4; r3 &= r4; \
   r1 ^= r2; r2 ^= r0; \
   r0 |= r2; r4 ^= r1; \
   r0 ^= r3; r3 ^= r4; \
   r4 |= r0; r3 ^= r2; \
   r4 ^= r2; \
   r2 = r1; r1 = r0; r0 = r3; r3 = r4; \
}

//Linear transformation
#define LT(x0, x1, x2, x3) \
{ \
   x0 = ROL32(x0, 13); \
   x2 = ROL32(x2, 3); \
   x1 ^= x0 ^ x2; \
   x3 ^= x2 ^ (x0 << 3); \
   x1 = ROL32(x1, 1); \
   x3 = ROL32(x3, 7); \
   x0 ^= x1 ^ x3; \
   x2 ^= x3 ^ (x1 << 7); \
   x0 = ROL32(x0, 5); \
   x2 = ROL32(x2, 22); \
}

//Inverse linear transformation
#define LT_INV(x0, x1, x2, x3) \
{ \
   x2 = ROR32(x2, 22); \
   x0 = ROR32(x0, 5); \
   x2 ^= x3 ^ (x1 << 7); \
   x0 ^= x1 ^ x3; \
   x3 = ROR32(x3, 7); \
   x1 = ROR32(x1, 1); \
   x3 ^= x2 ^ (x0 << 3); \
   x1 ^= x0 ^ x2; \
   x2 = ROR32(x2, 3); \
   x0 = ROR32(x0, 13); \
}

//XOR operation
#define XOR(x0, x1, x2, x3, k) \
{ \
   x0 ^= k[0]; \
   x1 ^= k[1]; \
   x2 ^= k[2]; \
   x3 ^= k[3]; \
}

//Encryption round
#define ROUND(n, x0, x1, x2, x3, k) \
{ \
   XOR(x0, x1, x2, x3, k); \
   SBOX##n(x0, x1, x2, x3); \
   LT(x0, x1, x2, x3); \
}

//Decryption round
#define ROUND_INV(n, x0, x1, x2, x3, k) \
{ \
   LT_INV(x0, x1, x2, x3); \
   SBOX##n##_INV(x0, x1, x2, x3); \
   XOR(x0, x1, x2, x3, k); \
}

/**
 * @brief Key expansion
 * @param[in] context Pointer to the Serpent context to initialize
 * @param[in] key Pointer to the key
 * @param[in] keyLen Length of the key
 **/

void serpentInit(SerpentContext *context, const uint8_t *key, size_t keyLen)
{
   uint_t i;
   uint32_t t;
   uint32_t *w;
   uint32_t p[8];

   //Determine the number of 32-bit words in the key
   keyLen /= 4;

   //Copy the original key
   for(i = 0; i < keyLen; i++)
   {
      p[i] = LOAD32LE(key + i * 4);
   }

   //Short keys with less than 256 bits are mapped to full-length keys of 256
   //bits by appending one '1' bit to the MSB end
   if(i < 8)
   {
      p[i++] = 0x00000001;
   }

   //Append as many '0' bits as required to make up 256 bits
   while(i < 8)
   {
      p[i++] = 0;
   }

   //Point to the intermediate prekey
   w = (uint32_t *) context->k;

   //Generate the first 8 words of the prekey
   t = p[0] ^ p[3] ^ p[5] ^ p[7] ^ PHI ^ 0;
   w[0] = ROL32(t, 11);
   t = p[1] ^ p[4] ^ p[6] ^ w[0] ^ PHI ^ 1;
   w[1] = ROL32(t, 11);
   t = p[2] ^ p[5] ^ p[7] ^ w[1] ^ PHI ^ 2;
   w[2] = ROL32(t, 11);
   t = p[3] ^ p[6] ^ w[0] ^ w[2] ^ PHI ^ 3;
   w[3] = ROL32(t, 11);
   t = p[4] ^ p[7] ^ w[1] ^ w[3] ^ PHI ^ 4;
   w[4] = ROL32(t, 11);
   t = p[5] ^ w[0] ^ w[2] ^ w[4] ^ PHI ^ 5;
   w[5] = ROL32(t, 11);
   t = p[6] ^ w[1] ^ w[3] ^ w[5] ^ PHI ^ 6;
   w[6] = ROL32(t, 11);
   t = p[7] ^ w[2] ^ w[4] ^ w[6] ^ PHI ^ 7;
   w[7] = ROL32(t, 11);

   //Expand the prekey using affine recurrence
   for(i = 8; i < 132; i++)
   {
      t = w[i - 8] ^ w[i - 5] ^ w[i - 3] ^ w[i - 1] ^ PHI ^ i;
      w[i] = ROL32(t, 11);
   }

   //The round keys are now calculated from the prekeys using the S-boxes
   for(i = 0; i < 128; i += 32)
   {
      SBOX3(w[i + 0], w[i + 1], w[i + 2], w[i + 3]);
      SBOX2(w[i + 4], w[i + 5], w[i + 6], w[i + 7]);
      SBOX1(w[i + 8], w[i + 9], w[i + 10], w[i + 11]);
      SBOX0(w[i + 12], w[i + 13], w[i + 14], w[i + 15]);
      SBOX7(w[i + 16], w[i + 17], w[i + 18], w[i + 19]);
      SBOX6(w[i + 20], w[i + 21], w[i + 22], w[i + 23]);
      SBOX5(w[i + 24], w[i + 25], w[i + 26], w[i + 27]);
      SBOX4(w[i + 28], w[i + 29], w[i + 30], w[i + 31]);
   }

   //Calculate the last round key
   SBOX3(w[128], w[129], w[130], w[131]);

   //Successful initialization
}

/**
 * @brief Encrypt a 16-byte block using Serpent algorithm
 * @param[in] context Pointer to the Serpent context
 * @param[in] input Plaintext block to encrypt
 * @param[out] output Ciphertext block resulting from encryption
 **/
#if defined (OP_encrypt)
void serpentEncryptBlock(SerpentContext *context, const uint8_t *input,
   uint8_t *output)
{
   uint_t i;
   uint32_t r0;
   uint32_t r1;
   uint32_t r2;
   uint32_t r3;

   //The 16 bytes of plaintext are split into 4 words
   r0 = LOAD32LE(input);
   r1 = LOAD32LE(input + 4);
   r2 = LOAD32LE(input + 8);
   r3 = LOAD32LE(input + 12);

   //The 32 rounds use 8 different S-boxes
   for(i = 0; i < 32; i += 8)
   {
      ROUND(0, r0, r1, r2, r3, context->k[i]);
      ROUND(1, r0, r1, r2, r3, context->k[i + 1]);
      ROUND(2, r0, r1, r2, r3, context->k[i + 2]);
      ROUND(3, r0, r1, r2, r3, context->k[i + 3]);
      ROUND(4, r0, r1, r2, r3, context->k[i + 4]);
      ROUND(5, r0, r1, r2, r3, context->k[i + 5]);
      ROUND(6, r0, r1, r2, r3, context->k[i + 6]);
      ROUND(7, r0, r1, r2, r3, context->k[i + 7]);
   }

   //In the last round, the linear transformation is replaced by an additional
   //key mixing
   LT_INV(r0, r1, r2, r3);
   XOR(r0, r1, r2, r3, context->k[32]);

   //The 4 words of ciphertext are then written as 16 bytes
   STORE32LE(r0, output);
   STORE32LE(r1, output + 4);
   STORE32LE(r2, output + 8);
   STORE32LE(r3, output + 12);
}
#endif

/**
 * @brief Decrypt a 16-byte block using Serpent algorithm
 * @param[in] context Pointer to the Serpent context
 * @param[in] input Ciphertext block to decrypt
 * @param[out] output Plaintext block resulting from decryption
 **/
#if defined (OP_decrypt)
void serpentDecryptBlock(SerpentContext *context, const uint8_t *input,
   uint8_t *output)
{
   uint_t i;
   uint32_t r0;
   uint32_t r1;
   uint32_t r2;
   uint32_t r3;

   //The 16 bytes of ciphertext are split into 4 words
   r0 = LOAD32LE(input);
   r1 = LOAD32LE(input + 4);
   r2 = LOAD32LE(input + 8);
   r3 = LOAD32LE(input + 12);

   //In the first decryption round, the inverse linear transformation is
   //replaced by an additional key mixing
   XOR(r0, r1, r2, r3, context->k[32]);
   LT(r0, r1, r2, r3);

   //Decryption is different from encryption in that the inverse of the
   //S-boxes must be used in the reverse order, as well as the inverse linear
   //transformation and reverse order of the subkeys
   for(i = 0; i < 32; i += 8)
   {
      ROUND_INV(7, r0, r1, r2, r3, context->k[31 - i]);
      ROUND_INV(6, r0, r1, r2, r3, context->k[30 - i]);
      ROUND_INV(5, r0, r1, r2, r3, context->k[29 - i]);
      ROUND_INV(4, r0, r1, r2, r3, context->k[28 - i]);
      ROUND_INV(3, r0, r1, r2, r3, context->k[27 - i]);
      ROUND_INV(2, r0, r1, r2, r3, context->k[26 - i]);
      ROUND_INV(1, r0, r1, r2, r3, context->k[25 - i]);
      ROUND_INV(0, r0, r1, r2, r3, context->k[24 - i]);
   }

   //The 4 words of plaintext are then written as 16 bytes
   STORE32LE(r0, output);
   STORE32LE(r1, output + 4);
   STORE32LE(r2, output + 8);
   STORE32LE(r3, output + 12);
}
#endif

const struct test
  {
    int key_length;
    unsigned char key[32];
    unsigned char text_plain[16];
    unsigned char text_cipher[16];
  } test_data[] =
    {
      {
	16,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\xD2\x9D\x57\x6F\xCE\xA3\xA3\xA7\xED\x90\x99\xF2\x92\x73\xD7\x8E",
	"\xB2\x28\x8B\x96\x8A\xE8\xB0\x86\x48\xD1\xCE\x96\x06\xFD\x99\x2D"
      },
      {
	24,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00",
	"\xD2\x9D\x57\x6F\xCE\xAB\xA3\xA7\xED\x98\x99\xF2\x92\x7B\xD7\x8E",
	"\x13\x0E\x35\x3E\x10\x37\xC2\x24\x05\xE8\xFA\xEF\xB2\xC3\xC3\xE9"
      },
      {
	32,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\xD0\x95\x57\x6F\xCE\xA3\xE3\xA7\xED\x98\xD9\xF2\x90\x73\xD7\x8E",
	"\xB9\x0E\xE5\x86\x2D\xE6\x91\x68\xF2\xBD\xD5\x12\x5B\x45\x47\x2B"
      },
      {
	32,
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
	"\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00",
	"\x20\x61\xA4\x27\x82\xBD\x52\xEC\x69\x1E\xC3\x83\xB0\x3B\xA7\x7C"
      },
      {
	0
      },
    };
#endif

void testSerpent (void)
{
#ifndef LACK_OF_MEMORY
  SerpentContext context;
  unsigned char scratch[16];
  unsigned int i;

  for (i = 0; test_data[i].key_length; i++)
    {
      serpentInit(&context, test_data[i].key, test_data[i].key_length);
#ifndef __SDCC_ds390 // Bug #3905
#if !defined(__SDCC_stm8) && !defined(__SDCC_f8) // Bugs #3906, 3907.
#if defined(OP_encrypt)
      serpentEncryptBlock(&context, test_data[i].text_plain, scratch);
      ASSERT (!memcmp (scratch, test_data[i].text_cipher, sizeof (scratch)));
#endif
#endif

#if defined(OP_decrypt)
      serpentDecryptBlock(&context, test_data[i].text_cipher, scratch);
      ASSERT (!memcmp (scratch, test_data[i].text_plain, sizeof (scratch)));
#endif
#endif
    }
#endif
}

