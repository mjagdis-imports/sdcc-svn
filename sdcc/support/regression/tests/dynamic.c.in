/** dynamicc.c.in - test Dynamic C calling convention support.
    AFAIK the original Dynamic C only supported Z180 and the Rabbits.
    We support this calling convention for all Z80-like architectures that have ix, though.

    rtype: unsigned int, unsigned long
*/
#include <testfwk.h>

#if !defined(__SDCC_z80) && !defined(__SDCC_z80n) && !defined(__SDCC_z180) && !defined(__SDCC_r2k) && !defined(__SDCC_r2ka) && !defined(__SDCC_r3ka) && !defined(__SDCC_r4k) && !defined(__SDCC_r5k) && !defined(__SDCC_r6k) && !defined(__SDCC_tlcs90) && !defined(__SDCC_ez80) && !defined(__SDCC_r800)
#define __dynamicc
#endif

#define VAL 0xaa55a55a

void fnoret(void) __dynamicc
{
}

{rtype} fret(void) __dynamicc
{
  return (({rtype})VAL);
}

// A function that uses the stack a lot, so the frame pointer is unlikely to be omitted.
int frameptruser (char i, int j, long k, long long l)
{
  volatile int a[5];
  a[0] = i; a[1] = j; a[2] = k, a[3] = l;
  
  // __dynamicc has the caller save ix (used as framepointer by SDCC).
  a[4] = fret ();
  fnoret ();
  
  return (a[0] + a[1] + a[2] + a[3] + a[4]); // The reads from the array should use the frame pointer.
}

// TODO: test unsigned char return when supported for __dynamicc
// TODO: test struct/union return when supported for __dynamicc
// TODO: test parameter passing when supported for __dynamicc

void testDynamicC(void)
{
  ASSERT (fret () == ({rtype})VAL);
  ASSERT (frameptruser (1, 2, 3, 4) == 1 + 2 + 3 + 4 + (int)({rtype})VAL);
}

